#!/bin/bash

# Configuration
VOICEMEMO_DIR="$HOME/Library/Group Containers/group.com.apple.VoiceMemos.shared/Recordings"
OUTPUT_DIR="$HOME/Documents/VoiceMemos"
PROCESSED_LIST="$HOME/.voicememo_processed"
LOG_FILE="$HOME/.voicememo_processing.log"

# Handle -help flag
if [[ "$1" == "-help" ]] || [[ "$1" == "-h" ]]; then
    echo "Usage: xcribe [options]"
    echo ""
    echo "Options:"
    echo "  -f <file>   Process a single audio file instead of the Voice Memos directory"
    echo "  -d <dir>    Process all audio files in a different directory"
    echo "  -l          Use Whisper large-v3 model (default: base)"
    echo "  -r          Process files in reverse order (oldest first)"
    echo "  -dry        Dry run: show what would be processed without transcribing"
    echo "  -log        Show processing log"
    echo "  -old        Show archived pre-v2 log"
    echo "  -help, -h   Show this help message"
    echo ""
    echo "Examples:"
    echo "  xcribe                    # Process all new Voice Memos"
    echo "  xcribe -l                 # Process with large model"
    echo "  xcribe -f recording.m4a   # Process a single file"
    echo "  xcribe -f recording.m4a -l  # Single file with large model"
    echo "  xcribe -d ~/AudioImports  # Process files from a different directory"
    exit 0
fi

# Handle -log flag: show directories and log, then exit
if [[ "$1" == "-log" ]]; then
    echo "Voicememos dir: $VOICEMEMO_DIR"
    echo "Transcripts dir: $OUTPUT_DIR"
    echo ""
    if [[ -f "$LOG_FILE" ]]; then
        tac "$LOG_FILE" | more
    else
        echo "No log file found at $LOG_FILE"
    fi
    exit 0
fi

# Handle -old flag: show archived pre-v2 log
if [[ "$1" == "-old" ]]; then
    if [[ -f "${LOG_FILE}.pre-v2" ]]; then
        tac "${LOG_FILE}.pre-v2" | more
    else
        echo "No archived log at ${LOG_FILE}.pre-v2"
    fi
    exit 0
fi

# Rotate old format log if it exists and hasn't been rotated yet
if [[ -f "$LOG_FILE" ]] && ! [[ -f "${LOG_FILE}.pre-v2" ]]; then
    if grep -q '^\[' "$LOG_FILE"; then
        mv "$LOG_FILE" "${LOG_FILE}.pre-v2"
    fi
fi

# Parse command line arguments
REVERSE_ORDER=false
USE_LARGE_MODEL=false
DRY_RUN=false
SINGLE_FILE=""
CUSTOM_DIR=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -r) REVERSE_ORDER=true; shift ;;
        -l) USE_LARGE_MODEL=true; shift ;;
        -dry) DRY_RUN=true; shift ;;
        -f)
            if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                echo "Error: -f requires a filename argument"
                exit 1
            fi
            SINGLE_FILE="$2"
            shift 2
            ;;
        -d)
            if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                echo "Error: -d requires a directory argument"
                exit 1
            fi
            CUSTOM_DIR="$2"
            shift 2
            ;;
        *) shift ;;  # Skip unknown args (like -log, -old handled above)
    esac
done

# Override default directory if -d was specified
if [ -n "$CUSTOM_DIR" ]; then
    if [ ! -d "$CUSTOM_DIR" ]; then
        echo "Error: Directory not found: $CUSTOM_DIR"
        exit 1
    fi
    VOICEMEMO_DIR="$CUSTOM_DIR"
fi

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Create processed list file if it doesn't exist
touch "$PROCESSED_LIST"

# Function to log messages (ISO 8601 format: YYYY-MM-DD-HH-MM-SS)
log_message() {
    local message="$(date '+%Y-%m-%d-%H-%M-%S')\t$1"
    echo -e "$message" >> "$LOG_FILE"
    echo -e "$message"
}

# Function to get simple topic from keywords
get_simple_topic() {
    local transcript="$1"
    local topic="voicememo"

    # Convert to lowercase for matching
    local lower_transcript=$(echo "$transcript" | tr '[:upper:]' '[:lower:]')

    # Check for common keywords and patterns
    if echo "$lower_transcript" | grep -q -E '\b(meeting|call|conference|discussion|talk|spoke|conversation)\b'; then
        topic="meeting"
    elif echo "$lower_transcript" | grep -q -E '\b(dear|recap|follow.up|followup)\b'; then
        topic="followup"
    elif echo "$lower_transcript" | grep -q -E '\b(grocery|shopping|store|buy)\b'; then
        topic="shopping"
    elif echo "$lower_transcript" | grep -q -E '\b(todo|task|reminder|remember)\b'; then
        topic="reminder"
    elif echo "$lower_transcript" | grep -q -E '\b(idea|thought|concept|brainstorm)\b'; then
        topic="idea"
    elif echo "$lower_transcript" | grep -q -E '\b(work|project|job|office)\b'; then
        topic="work"
    elif echo "$lower_transcript" | grep -q -E '\b(personal|family|home)\b'; then
        topic="personal"
    elif echo "$lower_transcript" | grep -q -E '\b(note|notes|memo)\b'; then
        topic="note"
    fi

    echo "$topic"
}

# Function to get topic from Claude
get_topic_from_claude() {
    local transcript="$1"
    local topic
    local temp_file="/tmp/transcript_for_analysis_$$"

    # Debug: log transcript length and first few words
    local transcript_length=$(echo "$transcript" | wc -c | tr -d ' ')
    local first_words=$(echo "$transcript" | head -c 100)
    echo "  -> DEBUG: Transcript length: $transcript_length chars, first 100 chars: $first_words" >> "$LOG_FILE"

    # Create prompt file for Claude
    cat > "$temp_file" << 'PROMPT'
Analyze this voice memo transcript and extract the main topic.

Requirements:
- Return ONLY 1-2 descriptive words that capture the main subject
- Use underscores instead of spaces (e.g., meeting_notes, grocery_list)
- Be specific and descriptive
- Use lowercase
- No punctuation except underscores
- If it's about a person, use their name (e.g., john_call)
- If it's a type of content, be specific (e.g., work_update, family_news, todo_list)

Examples of good topics:
- meeting_recap
- grocery_list
- work_update
- family_call
- idea_brainstorm
- doctor_appointment
- travel_plans

Output only the topic, nothing else.

Transcript:
PROMPT

    echo "$transcript" >> "$temp_file"

    # Use Claude to analyze the transcript
    topic=$(claude --print < "$temp_file" 2>/dev/null | head -n 1 | tr ' ' '_' | tr -cd '[:alnum:]_-' | tr '[:upper:]' '[:lower:]')

    # Debug: log raw Claude output
    echo "  -> DEBUG: Raw Claude output: '$topic'" >> "$LOG_FILE"

    # Default to simple keyword extraction if Claude fails or returns empty
    if [ -z "$topic" ] || [ ${#topic} -lt 2 ]; then
        echo "  -> DEBUG: Claude failed, trying simple keyword extraction" >> "$LOG_FILE"
        topic=$(get_simple_topic "$transcript")
        echo "  -> DEBUG: Simple extraction result: '$topic'" >> "$LOG_FILE"
    fi

    # Cleanup temp file
    rm -f "$temp_file"

    echo "$topic"
}

# Function to process a single audio file
process_file() {
    local voice_file="$1"
    local file_num="$2"
    local total_num="$3"

    # Get file basename and full path hash for tracking
    local file_basename=$(basename "$voice_file")
    local file_hash=$(echo "$voice_file" | md5)
    local file_size=$(ls -lh "$voice_file" | awk '{print $5}')

    log_message "[$file_num/$total_num] Checking file: $file_basename (${file_size})"

    # Determine which model to use
    local whisper_model
    if [ "$USE_LARGE_MODEL" = true ]; then
        whisper_model="large-v3"
    else
        whisper_model="base"
    fi

    # Check if already processed with this model (format: hash:model)
    local processed_key="${file_hash}:${whisper_model}"
    if grep -q "^${processed_key}$" "$PROCESSED_LIST"; then
        log_message "  -> Skipping: already processed with ${whisper_model} model"
        return 0
    fi

    # Dry run mode: show what would be processed and stop
    if [ "$DRY_RUN" = true ]; then
        log_message "  -> [DRY RUN] Would process with ${whisper_model} model"
        return 0
    fi

    log_message "  -> Processing new file..."

    # Generate timestamp from file modification time
    local file_mod_time=$(stat -f "%m" "$voice_file")
    local timestamp=$(date -r "$file_mod_time" +%Y_%m_%dT%Hh%Mm%Ss)

    log_message "  -> Running Whisper transcription with $whisper_model model (this may take a moment)..."
    # Run Whisper to transcribe (use venv whisper to avoid system numpy conflicts)
    if /Users/wiggins/.local/venvs/whisper/bin/whisper "$voice_file" --model "$whisper_model" --output_format txt --output_dir /tmp --language en >/dev/null 2>&1; then
        log_message "  -> Whisper transcription completed successfully"
    else
        log_message "  -> ERROR: Whisper transcription failed"
        return 1
    fi

    # Find the generated transcript file (Whisper creates it with the original filename, minus extension)
    local file_noext="${file_basename%.*}"
    local whisper_output="/tmp/${file_noext}.txt"

    if [ -f "$whisper_output" ]; then
        # Read the transcript
        local transcript=$(cat "$whisper_output")
        local transcript_length=$(echo "$transcript" | wc -c | tr -d ' ')
        log_message "  -> Transcript generated: ${transcript_length} characters"

        # Get topic from transcript
        log_message "  -> Analyzing transcript for topic..."
        local topic=$(get_topic_from_claude "$transcript")
        log_message "  -> Topic identified: $topic"

        # Create output filename with topic and model
        local output_file="${OUTPUT_DIR}/${topic}_${timestamp}_${whisper_model}.md"

        # Write to markdown file with metadata
        {
            echo "# Voice Memo: ${topic}"
            echo ""
            echo "**Date:** $(date -r "$file_mod_time" '+%Y-%m-%d %H:%M:%S')"
            echo "**Original File:** ${file_basename}"
            echo ""
            echo "---"
            echo ""
            echo "${transcript}"
        } > "$output_file"

        # Add to processed list with model (format: hash:model)
        echo "$processed_key" >> "$PROCESSED_LIST"

        local output_size=$(ls -lh "$output_file" | awk '{print $5}')
        local word_count=$(wc -w < "$output_file" | tr -d ' ')
        log_message "$(basename "$output_file")\tsz:${output_size}\twc:${word_count}"

        # Clean up temporary transcript
        rm -f "$whisper_output"
    else
        log_message "  -> ERROR: Transcript file not found after Whisper processing"
        return 1
    fi
}

# Process voice memos
log_message "Starting voice memo processing"
if [ "$DRY_RUN" = true ]; then
    log_message "*** DRY RUN MODE - no files will be transcribed ***"
fi
log_message "Output directory: $OUTPUT_DIR"

if [ -n "$SINGLE_FILE" ]; then
    # Single file mode: process just the specified file
    if [ ! -f "$SINGLE_FILE" ]; then
        log_message "ERROR: File not found: $SINGLE_FILE"
        exit 1
    fi
    log_message "Single file mode: $SINGLE_FILE"
    process_file "$SINGLE_FILE" 1 1
else
    # Directory mode: process all voice memos
    log_message "Scanning directory: $VOICEMEMO_DIR"

    # Define supported audio file types
    AUDIO_EXTENSIONS="m4a"
    log_message "Looking for file types: $AUDIO_EXTENSIONS"

    # Census: count files by type
    m4a_count=$(find "$VOICEMEMO_DIR" -name "*.m4a" -type f 2>/dev/null | wc -l | tr -d ' ')
    log_message "Census: .m4a=$m4a_count"

    total_files=$m4a_count
    if [ "$total_files" -eq 0 ]; then
        log_message "No audio files found in $VOICEMEMO_DIR"
        exit 0
    fi
    log_message "Total files to check: $total_files"

    # Find all audio files in directory, sorted by modification time
    # Default: newest first (-t), with -r flag: oldest first (-tr)
    file_counter=0
    if [ "$REVERSE_ORDER" = true ]; then
        file_list=$(find "$VOICEMEMO_DIR" -name "*.m4a" -type f -print0 | xargs -0 ls -tr 2>/dev/null)
    else
        file_list=$(find "$VOICEMEMO_DIR" -name "*.m4a" -type f -print0 | xargs -0 ls -t 2>/dev/null)
    fi

    echo "$file_list" | while read -r voice_file; do
        file_counter=$((file_counter + 1))
        process_file "$voice_file" "$file_counter" "$total_files"
    done
fi

log_message "Voice memo processing completed"
