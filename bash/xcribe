#!/bin/bash

# Configuration
VOICEMEMO_DIR="$HOME/Library/Group Containers/group.com.apple.VoiceMemos.shared/Recordings"
OUTPUT_DIR="$HOME/Documents/VoiceMemos"
PROCESSED_LIST="$HOME/.voicememo_processed"
LOG_FILE="$HOME/.voicememo_processing.log"

# Handle -help flag
if [[ "$1" == "-help" ]] || [[ "$1" == "-h" ]]; then
    echo "Usage: xcribe [options]"
    echo ""
    echo "Options:"
    echo "  -f <file>   Process a single audio file instead of the Voice Memos directory"
    echo "  -d <dir>    Process all audio files in a different directory"
    echo "  -l          Use Whisper large-v3 model"
    echo "  -small      Use Whisper small model (faster than base, good accuracy)"
    echo "  -tiny       Use Whisper tiny model (fastest, lower accuracy)"
    echo "              (default: base model)"
    echo "  -parallel N Limit to N parallel jobs (default: unlimited)"
    echo "  -r          Process files in reverse order (oldest first)"
    echo "  -dry        Dry run: show what would be processed without transcribing"
    echo "  -log        Show processing log"
    echo "  -old        Show archived pre-v2 log"
    echo "  -help, -h   Show this help message"
    echo ""
    echo "Examples:"
    echo "  xcribe                    # Process all new Voice Memos"
    echo "  xcribe -l                 # Process with large model"
    echo "  xcribe -tiny              # Process with tiny model (fastest)"
    echo "  xcribe -small -parallel 2 # Small model, 2 jobs at a time"
    echo "  xcribe -f recording.m4a   # Process a single file"
    echo "  xcribe -f recording.m4a -l  # Single file with large model"
    echo "  xcribe -d ~/AudioImports  # Process files from a different directory"
    echo ""
    echo "Watch progress:"
    echo "  tail -f /tmp/*.txt        # See partial transcripts as they're written"
    exit 0
fi

# Handle -log flag: show directories and log, then exit
if [[ "$1" == "-log" ]]; then
    echo "Voicememos dir: $VOICEMEMO_DIR"
    echo "Transcripts dir: $OUTPUT_DIR"
    echo ""
    if [[ -f "$LOG_FILE" ]]; then
        tac "$LOG_FILE" | more
    else
        echo "No log file found at $LOG_FILE"
    fi
    exit 0
fi

# Handle -old flag: show archived pre-v2 log
if [[ "$1" == "-old" ]]; then
    if [[ -f "${LOG_FILE}.pre-v2" ]]; then
        tac "${LOG_FILE}.pre-v2" | more
    else
        echo "No archived log at ${LOG_FILE}.pre-v2"
    fi
    exit 0
fi

# Rotate old format log if it exists and hasn't been rotated yet
if [[ -f "$LOG_FILE" ]] && ! [[ -f "${LOG_FILE}.pre-v2" ]]; then
    if grep -q '^\[' "$LOG_FILE"; then
        mv "$LOG_FILE" "${LOG_FILE}.pre-v2"
    fi
fi

# Parse command line arguments
REVERSE_ORDER=false
WHISPER_MODEL="base"
DRY_RUN=false
SINGLE_FILE=""
CUSTOM_DIR=""
PARALLEL_JOBS=0  # 0 = unlimited
while [[ $# -gt 0 ]]; do
    case "$1" in
        -r) REVERSE_ORDER=true; shift ;;
        -l) WHISPER_MODEL="large-v3"; shift ;;
        -small) WHISPER_MODEL="small"; shift ;;
        -tiny) WHISPER_MODEL="tiny"; shift ;;
        -dry) DRY_RUN=true; shift ;;
        -parallel)
            if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                echo "Error: -parallel requires a number argument"
                exit 1
            fi
            PARALLEL_JOBS="$2"
            shift 2
            ;;
        -f)
            if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                echo "Error: -f requires a filename argument"
                exit 1
            fi
            SINGLE_FILE="$2"
            shift 2
            ;;
        -d)
            if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                echo "Error: -d requires a directory argument"
                exit 1
            fi
            CUSTOM_DIR="$2"
            shift 2
            ;;
        *) shift ;;  # Skip unknown args (like -log, -old handled above)
    esac
done

# Override default directory if -d was specified
if [ -n "$CUSTOM_DIR" ]; then
    if [ ! -d "$CUSTOM_DIR" ]; then
        echo "Error: Directory not found: $CUSTOM_DIR"
        exit 1
    fi
    VOICEMEMO_DIR="$CUSTOM_DIR"
fi

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Create processed list file if it doesn't exist
touch "$PROCESSED_LIST"

# Lock directory for thread-safe operations (mkdir is atomic on macOS)
LOCK_DIR="/tmp/xcribe_lock_$$"

# Function to acquire lock (macOS-compatible using mkdir)
acquire_lock() {
    while ! mkdir "$LOCK_DIR" 2>/dev/null; do
        sleep 0.05
    done
}

# Function to release lock
release_lock() {
    rmdir "$LOCK_DIR" 2>/dev/null
}

# Function to log messages (ISO 8601 format: YYYY-MM-DD-HH-MM-SS)
log_message() {
    local message="$(date '+%Y-%m-%d-%H-%M-%S')\t$1"
    acquire_lock
    echo -e "$message" >> "$LOG_FILE"
    echo -e "$message"
    release_lock
}

# Function to get simple topic from keywords
get_simple_topic() {
    local transcript="$1"
    local topic="voicememo"

    # Convert to lowercase for matching
    local lower_transcript=$(echo "$transcript" | tr '[:upper:]' '[:lower:]')

    # Check for common keywords and patterns
    if echo "$lower_transcript" | grep -q -E '\b(meeting|call|conference|discussion|talk|spoke|conversation)\b'; then
        topic="meeting"
    elif echo "$lower_transcript" | grep -q -E '\b(dear|recap|follow.up|followup)\b'; then
        topic="followup"
    elif echo "$lower_transcript" | grep -q -E '\b(grocery|shopping|store|buy)\b'; then
        topic="shopping"
    elif echo "$lower_transcript" | grep -q -E '\b(todo|task|reminder|remember)\b'; then
        topic="reminder"
    elif echo "$lower_transcript" | grep -q -E '\b(idea|thought|concept|brainstorm)\b'; then
        topic="idea"
    elif echo "$lower_transcript" | grep -q -E '\b(work|project|job|office)\b'; then
        topic="work"
    elif echo "$lower_transcript" | grep -q -E '\b(personal|family|home)\b'; then
        topic="personal"
    elif echo "$lower_transcript" | grep -q -E '\b(note|notes|memo)\b'; then
        topic="note"
    fi

    echo "$topic"
}

# Function to get topic from Claude
get_topic_from_claude() {
    local transcript="$1"
    local topic
    local temp_file="/tmp/transcript_for_analysis_$$_$RANDOM"

    # Debug: log transcript length and first few words
    local transcript_length=$(echo "$transcript" | wc -c | tr -d ' ')
    local first_words=$(echo "$transcript" | head -c 100)
    echo "  -> DEBUG: Transcript length: $transcript_length chars, first 100 chars: $first_words" >> "$LOG_FILE"

    # Create prompt file for Claude
    cat > "$temp_file" << 'PROMPT'
Analyze this voice memo transcript and extract the main topic.

Requirements:
- Return ONLY 1-2 descriptive words that capture the main subject
- Use underscores instead of spaces (e.g., meeting_notes, grocery_list)
- Be specific and descriptive
- Use lowercase
- No punctuation except underscores
- If it's about a person, use their name (e.g., john_call)
- If it's a type of content, be specific (e.g., work_update, family_news, todo_list)

Examples of good topics:
- meeting_recap
- grocery_list
- work_update
- family_call
- idea_brainstorm
- doctor_appointment
- travel_plans

Output only the topic, nothing else.

Transcript:
PROMPT

    echo "$transcript" >> "$temp_file"

    # Use Claude to analyze the transcript
    topic=$(claude --print < "$temp_file" 2>/dev/null | head -n 1 | tr ' ' '_' | tr -cd '[:alnum:]_-' | tr '[:upper:]' '[:lower:]')

    # Debug: log raw Claude output
    echo "  -> DEBUG: Raw Claude output: '$topic'" >> "$LOG_FILE"

    # Default to simple keyword extraction if Claude fails or returns empty
    if [ -z "$topic" ] || [ ${#topic} -lt 2 ]; then
        echo "  -> DEBUG: Claude failed, trying simple keyword extraction" >> "$LOG_FILE"
        topic=$(get_simple_topic "$transcript")
        echo "  -> DEBUG: Simple extraction result: '$topic'" >> "$LOG_FILE"
    fi

    # Cleanup temp file
    rm -f "$temp_file"

    echo "$topic"
}

# Function to process a single audio file
process_file() {
    local voice_file="$1"
    local file_num="$2"
    local total_num="$3"
    local whisper_model="$4"

    # Get file basename and full path hash for tracking
    local file_basename=$(basename "$voice_file")
    local file_hash=$(echo "$voice_file" | md5)
    local file_size=$(ls -lh "$voice_file" | awk '{print $5}')

    log_message "[$file_num/$total_num] Checking file: $file_basename (${file_size})"

    # Check if already processed with this model (format: hash:model)
    local processed_key="${file_hash}:${whisper_model}"
    if grep -q "^${processed_key}$" "$PROCESSED_LIST"; then
        log_message "  -> Skipping: already processed with ${whisper_model} model"
        return 0
    fi

    # Dry run mode: show what would be processed and stop
    if [ "$DRY_RUN" = true ]; then
        log_message "  -> [DRY RUN] Would process with ${whisper_model} model"
        return 0
    fi

    log_message "  -> Processing new file with ${whisper_model} model..."

    # Generate timestamp from file modification time
    local file_mod_time=$(stat -f "%m" "$voice_file")
    local timestamp=$(date -r "$file_mod_time" +%Y_%m_%dT%Hh%Mm%Ss)

    log_message "  -> Running Whisper transcription (progress below)..."

    # Run Whisper to transcribe - NO output suppression so progress bar shows
    # Using faster-whisper if available, falls back to regular whisper
    local whisper_output="/tmp/${file_basename%.*}.txt"

    if /Users/wiggins/.local/venvs/whisper/bin/python3 -c "import faster_whisper" 2>/dev/null; then
        # Use faster-whisper (significantly faster with CTranslate2)
        /Users/wiggins/.local/venvs/whisper/bin/python3 - "$whisper_model" "$voice_file" "$whisper_output" <<'PYTHON_SCRIPT'
import sys
from faster_whisper import WhisperModel

model_name = sys.argv[1]
input_file = sys.argv[2]
output_file = sys.argv[3]

model = WhisperModel(model_name, device='auto', compute_type='auto')
segments, info = model.transcribe(input_file, language='en')

print(f'Detected language: {info.language} (probability {info.language_probability:.2f})', file=sys.stderr)

with open(output_file, 'w') as f:
    for segment in segments:
        line = f'[{segment.start:.2f}s -> {segment.end:.2f}s] {segment.text.strip()}'
        print(line, file=sys.stderr)
        f.write(line + '\n')
PYTHON_SCRIPT
        local whisper_exit=$?
    else
        # Fallback to regular whisper (using Python API for timestamped output)
        /Users/wiggins/.local/venvs/whisper/bin/python3 - "$whisper_model" "$voice_file" "$whisper_output" <<'PYTHON_FALLBACK'
import sys
import whisper

model_name = sys.argv[1]
input_file = sys.argv[2]
output_file = sys.argv[3]

model = whisper.load_model(model_name)
result = model.transcribe(input_file, language='en')

with open(output_file, 'w') as f:
    for segment in result['segments']:
        line = f'[{segment["start"]:.2f}s -> {segment["end"]:.2f}s] {segment["text"].strip()}'
        print(line, file=sys.stderr)
        f.write(line + '\n')
PYTHON_FALLBACK
        local whisper_exit=$?
    fi

    if [ $whisper_exit -eq 0 ]; then
        log_message "  -> Whisper transcription completed successfully"
    else
        log_message "  -> ERROR: Whisper transcription failed"
        return 1
    fi

    if [ -f "$whisper_output" ]; then
        # Read the transcript
        local transcript=$(cat "$whisper_output")
        local transcript_length=$(echo "$transcript" | wc -c | tr -d ' ')
        log_message "  -> Transcript generated: ${transcript_length} characters"

        # Get topic from transcript
        log_message "  -> Analyzing transcript for topic..."
        local topic=$(get_topic_from_claude "$transcript")
        log_message "  -> Topic identified: $topic"

        # Create output filename with topic and model
        local output_file="${OUTPUT_DIR}/${topic}_${timestamp}_${whisper_model}.md"

        # Write to markdown file with metadata
        {
            echo "# Voice Memo: ${topic}"
            echo ""
            echo "**Date:** $(date -r "$file_mod_time" '+%Y-%m-%d %H:%M:%S')"
            echo "**Original File:** ${file_basename}"
            echo "**Model:** ${whisper_model}"
            echo ""
            echo "---"
            echo ""
            echo "## Transcript"
            echo ""
            echo '```'
            echo "${transcript}"
            echo '```'
        } > "$output_file"

        # Add to processed list with model (format: hash:model) - thread-safe
        acquire_lock
        echo "$processed_key" >> "$PROCESSED_LIST"
        release_lock

        local output_size=$(ls -lh "$output_file" | awk '{print $5}')
        local word_count=$(wc -w < "$output_file" | tr -d ' ')
        log_message "$(basename "$output_file")\tsz:${output_size}\twc:${word_count}"

        # Clean up temporary transcript
        rm -f "$whisper_output"
    else
        log_message "  -> ERROR: Transcript file not found after Whisper processing"
        return 1
    fi
}

# Export functions and variables for parallel subshells
export -f process_file log_message get_topic_from_claude get_simple_topic acquire_lock release_lock
export WHISPER_MODEL DRY_RUN OUTPUT_DIR PROCESSED_LIST LOG_FILE LOCK_DIR

# Process voice memos
log_message "Starting voice memo processing"
if [ "$DRY_RUN" = true ]; then
    log_message "*** DRY RUN MODE - no files will be transcribed ***"
fi
log_message "Output directory: $OUTPUT_DIR"
log_message "Model: $WHISPER_MODEL"
if [ "$PARALLEL_JOBS" -eq 0 ]; then
    log_message "Parallelism: unlimited"
else
    log_message "Parallelism: $PARALLEL_JOBS jobs"
fi

if [ -n "$SINGLE_FILE" ]; then
    # Single file mode: process just the specified file
    if [ ! -f "$SINGLE_FILE" ]; then
        log_message "ERROR: File not found: $SINGLE_FILE"
        exit 1
    fi
    log_message "Single file mode: $SINGLE_FILE"
    process_file "$SINGLE_FILE" 1 1 "$WHISPER_MODEL"
else
    # Directory mode: process all voice memos
    log_message "Scanning directory: $VOICEMEMO_DIR"

    # Define supported audio file types
    AUDIO_EXTENSIONS="m4a"
    log_message "Looking for file types: $AUDIO_EXTENSIONS"

    # Census: count files by type
    m4a_count=$(find "$VOICEMEMO_DIR" -name "*.m4a" -type f 2>/dev/null | wc -l | tr -d ' ')
    log_message "Census: .m4a=$m4a_count"

    total_files=$m4a_count
    if [ "$total_files" -eq 0 ]; then
        log_message "No audio files found in $VOICEMEMO_DIR"
        exit 0
    fi
    log_message "Total files to check: $total_files"

    # Find all audio files in directory, sorted by modification time
    # Default: newest first (-t), with -r flag: oldest first (-tr)
    if [ "$REVERSE_ORDER" = true ]; then
        file_list=$(find "$VOICEMEMO_DIR" -name "*.m4a" -type f -print0 | xargs -0 ls -tr 2>/dev/null)
    else
        file_list=$(find "$VOICEMEMO_DIR" -name "*.m4a" -type f -print0 | xargs -0 ls -t 2>/dev/null)
    fi

    # Process files in parallel
    file_counter=0
    job_count=0

    while IFS= read -r voice_file; do
        [ -z "$voice_file" ] && continue
        file_counter=$((file_counter + 1))

        # Launch job in background
        process_file "$voice_file" "$file_counter" "$total_files" "$WHISPER_MODEL" &
        job_count=$((job_count + 1))

        # If parallel limit set, wait when we hit the limit
        if [ "$PARALLEL_JOBS" -gt 0 ] && [ "$job_count" -ge "$PARALLEL_JOBS" ]; then
            wait -n 2>/dev/null || wait  # wait -n waits for any one job (bash 4.3+)
            job_count=$((job_count - 1))
        fi
    done <<< "$file_list"

    # Wait for all remaining background jobs
    wait
fi

# Cleanup lock dir
rmdir "$LOCK_DIR" 2>/dev/null

log_message "Voice memo processing completed"
