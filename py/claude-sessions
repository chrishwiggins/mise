#!/usr/bin/env python3
"""
claude-sessions - Global Claude Code session picker.

Aggregates session metadata from all projects stored by Claude Code
in ~/.claude/projects/, presents them in fzf for interactive selection,
and resumes the chosen session with `claude --resume`.

Claude Code stores sessions per-project in:
    ~/.claude/projects/<mangled-path>/

where <mangled-path> is the absolute project path with / replaced by -.
Each project directory may contain:
  - sessions-index.json: a manifest with session metadata (sessionId,
    summary, modified date, message count, git branch, etc.)
  - {session-id}.jsonl: raw session transcript files

Older versions of Claude Code maintained sessions-index.json reliably,
but newer versions (circa late Jan 2026+) may not update it. This tool
handles both cases: it reads sessions-index.json when available, then
scans .jsonl files to discover any sessions not listed in an index.

This tool merges ALL sessions across ALL projects into one searchable
list, solving the problem that `claude --resume` only shows sessions
for the current working directory.

Path aliases:
    Long project paths are shortened for display using aliases loaded
    from ~/.config/claude-sessions/config.json. If the config file
    doesn't exist, a default one is created with a single universal
    alias (/private/tmp/ -> /tmp/, which is a macOS symlink artifact).

    Example config:
    {
        "path_aliases": {
            "/private/tmp/": "/tmp/"
        }
    }

    Add your own aliases to shorten paths you see often, e.g.:
    {
        "path_aliases": {
            "/private/tmp/": "/tmp/",
            "~/Projects/work/": "~/W/",
            "~/Documents/research/": "~/R/"
        }
    }

Usage:
    claude-sessions            # interactive fzf picker (all sessions)
    claude-sessions -d 7       # sessions from the last 7 days
    claude-sessions -d 1       # sessions from the last 24 hours
    claude-sessions -n 50      # show only 50 most recent
    claude-sessions -q "regex" # pre-filter by project or summary
    claude-sessions --search "covariance"  # full-text search session content
    claude-sessions --reindex  # force rebuild of the search index
    claude-sessions --list     # just print, no fzf
    claude-sessions --json     # output JSON for the selected session

Keybindings (in fzf):
    Enter     Resume the selected session
    ctrl-e    Edit the summary of the selected session (opens $EDITOR)

Custom summaries:
    Edited summaries are stored in ~/.config/claude-sessions/summaries.json
    as a {sessionId: summary} map. These override auto-generated summaries
    from sessions-index.json and are preserved across runs.

Dependencies:
    - fzf (brew install fzf) for interactive mode
    - Python 3.7+ (for datetime.fromisoformat)
"""

import json
import glob
import os
import sqlite3
import subprocess
import sys
import argparse
from datetime import datetime, timezone
from pathlib import Path

# XDG-conventional config location
CONFIG_DIR = os.path.expanduser("~/.config/claude-sessions")
CONFIG_FILE = os.path.join(CONFIG_DIR, "config.json")
SUMMARIES_FILE = os.path.join(CONFIG_DIR, "summaries.json")
SEARCH_DB = os.path.join(CONFIG_DIR, "search.db")

# Base directory for Claude Code project data
PROJECTS_DIR = os.path.expanduser("~/.claude/projects")

# Where Claude Code stores session indexes (one per project)
SESSIONS_GLOB = os.path.join(PROJECTS_DIR, "*/sessions-index.json")

# Default config: only includes universal, non-PII aliases.
# /private/tmp/ -> /tmp/ is a macOS thing: /tmp is a symlink to /private/tmp,
# but Claude Code stores the resolved path.
DEFAULT_CONFIG = {
    "path_aliases": {
        "/private/tmp/": "/tmp/"
    }
}


def load_config():
    """Load path aliases from config file, creating a default if absent.

    Returns a dict with a "path_aliases" key mapping long prefixes to
    short replacements. Aliases are applied in order, so put longer
    (more specific) prefixes first if they overlap.
    """
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE) as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: bad config at {CONFIG_FILE}: {e}", file=sys.stderr)
            return DEFAULT_CONFIG

    # First run: create default config
    os.makedirs(CONFIG_DIR, exist_ok=True)
    with open(CONFIG_FILE, "w") as f:
        json.dump(DEFAULT_CONFIG, f, indent=2)
        f.write("\n")
    return DEFAULT_CONFIG


def load_summaries():
    """Load custom summary overrides from summaries.json.

    Returns a dict mapping sessionId -> custom summary string.
    """
    if os.path.exists(SUMMARIES_FILE):
        try:
            with open(SUMMARIES_FILE) as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            return {}
    return {}


def save_summaries(summaries):
    """Write custom summary overrides to summaries.json."""
    os.makedirs(CONFIG_DIR, exist_ok=True)
    with open(SUMMARIES_FILE, "w") as f:
        json.dump(summaries, f, indent=2)
        f.write("\n")


def _extract_message_text(message):
    """Extract plain text from a user or assistant message object.

    Handles both string content and list-of-blocks content formats.
    Skips system-reminder blocks (injected by hooks, not real content).
    """
    if not isinstance(message, dict):
        return ""
    content = message.get("content", "")
    if isinstance(content, str):
        return content
    if isinstance(content, list):
        parts = []
        for block in content:
            if not isinstance(block, dict):
                continue
            if block.get("type") == "text":
                text = block.get("text", "")
                # Skip system-reminder injections
                if "<system-reminder>" in text:
                    continue
                parts.append(text)
        return " ".join(parts)
    return ""


def get_search_db(force_reindex=False):
    """Open or create the FTS5 search database.

    Creates tables on first run. If force_reindex is True, drops and
    recreates everything for a clean rebuild.
    """
    os.makedirs(CONFIG_DIR, exist_ok=True)
    db = sqlite3.connect(SEARCH_DB)
    db.execute("PRAGMA journal_mode=WAL")

    if force_reindex:
        db.execute("DROP TABLE IF EXISTS indexed_files")
        db.execute("DROP TABLE IF EXISTS session_fts")

    db.execute("""
        CREATE TABLE IF NOT EXISTS indexed_files (
            jsonl_path TEXT PRIMARY KEY,
            mtime_ns INTEGER,
            session_id TEXT
        )
    """)
    # FTS5 with porter stemming so "running" matches "run", etc.
    db.execute("""
        CREATE VIRTUAL TABLE IF NOT EXISTS session_fts USING fts5(
            session_id UNINDEXED,
            project_path UNINDEXED,
            role,
            content,
            tokenize='porter unicode61'
        )
    """)
    db.commit()
    return db


def update_search_index(db):
    """Incrementally update the FTS5 index from .jsonl session files.

    Walks ~/.claude/projects/ and indexes any .jsonl files that are new
    or have changed (by mtime). Removes index entries for deleted files.
    Prints progress to stderr.
    """
    if not os.path.isdir(PROJECTS_DIR):
        return

    # Build set of all current .jsonl paths with their mtimes
    current_files = {}  # path -> mtime_ns
    for project_dir in os.listdir(PROJECTS_DIR):
        full_dir = os.path.join(PROJECTS_DIR, project_dir)
        if not os.path.isdir(full_dir):
            continue
        try:
            entries = os.listdir(full_dir)
        except OSError:
            continue
        for fname in entries:
            if not fname.endswith(".jsonl"):
                continue
            fpath = os.path.join(full_dir, fname)
            try:
                st = os.stat(fpath)
                current_files[fpath] = st.st_mtime_ns
            except OSError:
                continue

    # Load already-indexed files
    indexed = {}
    for row in db.execute("SELECT jsonl_path, mtime_ns FROM indexed_files"):
        indexed[row[0]] = row[1]

    # Find files to index (new or changed) and files to remove (deleted)
    to_index = []
    for fpath, mtime_ns in current_files.items():
        if fpath not in indexed or indexed[fpath] != mtime_ns:
            to_index.append(fpath)

    to_remove = [p for p in indexed if p not in current_files]

    if not to_index and not to_remove:
        print("Search index is up to date.", file=sys.stderr)
        return

    # Remove stale entries
    for fpath in to_remove:
        old_sid = db.execute(
            "SELECT session_id FROM indexed_files WHERE jsonl_path = ?",
            (fpath,)
        ).fetchone()
        if old_sid:
            db.execute(
                "DELETE FROM session_fts WHERE session_id = ? AND rowid IN "
                "(SELECT rowid FROM session_fts WHERE session_id = ?)",
                (old_sid[0], old_sid[0])
            )
        db.execute("DELETE FROM indexed_files WHERE jsonl_path = ?", (fpath,))

    # Index new/changed files
    total = len(to_index)
    for i, fpath in enumerate(to_index, 1):
        session_id = os.path.splitext(os.path.basename(fpath))[0]
        mtime_ns = current_files[fpath]

        if i % 50 == 0 or i == total:
            print(f"\rIndexing: {i}/{total} sessions...", end="", file=sys.stderr)

        # Remove old entries for this file if it was previously indexed
        if fpath in indexed:
            db.execute(
                "DELETE FROM session_fts WHERE session_id = ?", (session_id,)
            )
            db.execute(
                "DELETE FROM indexed_files WHERE jsonl_path = ?", (fpath,)
            )

        # Parse the .jsonl and extract text
        project_path = ""
        try:
            with open(fpath) as f:
                for line in f:
                    try:
                        obj = json.loads(line)
                    except (json.JSONDecodeError, ValueError):
                        continue

                    if not project_path and "cwd" in obj:
                        project_path = obj["cwd"]

                    t = obj.get("type", "")
                    if t not in ("user", "assistant"):
                        continue

                    msg = obj.get("message", {})
                    text = _extract_message_text(msg)
                    if not text or len(text.strip()) < 3:
                        continue

                    role = msg.get("role", t)
                    db.execute(
                        "INSERT INTO session_fts "
                        "(session_id, project_path, role, content) "
                        "VALUES (?, ?, ?, ?)",
                        (session_id, project_path, role, text)
                    )
        except (IOError, OSError):
            continue

        # Record this file as indexed
        db.execute(
            "INSERT OR REPLACE INTO indexed_files "
            "(jsonl_path, mtime_ns, session_id) VALUES (?, ?, ?)",
            (fpath, mtime_ns, session_id)
        )

    db.commit()
    if total > 0:
        print(f"\rIndexed {total} sessions.{' ' * 20}", file=sys.stderr)


def search_sessions(db, query):
    """Search the FTS5 index and return matching session info.

    Returns a dict mapping session_id -> list of snippet strings,
    ordered by relevance (best matches first).
    """
    results = {}
    try:
        rows = db.execute(
            "SELECT session_id, project_path, "
            "snippet(session_fts, 3, '>>>', '<<<', '...', 40) as snip, "
            "rank "
            "FROM session_fts WHERE session_fts MATCH ? "
            "ORDER BY rank "
            "LIMIT 500",
            (query,)
        ).fetchall()
    except sqlite3.OperationalError as e:
        print(f"Search error: {e}", file=sys.stderr)
        print("Tip: use simple words or quoted phrases. "
              "FTS5 syntax: word1 word2 (AND), "
              "word1 OR word2, \"exact phrase\"", file=sys.stderr)
        return {}

    for session_id, project_path, snippet, rank in rows:
        if session_id not in results:
            results[session_id] = []
        # Keep up to 3 snippets per session
        if len(results[session_id]) < 3:
            results[session_id].append(snippet)

    return results


def load_all_sessions():
    """Load and merge session entries from all projects.

    Two-pass approach:
    1. Read sessions-index.json files (fast, has clean summaries).
    2. Scan .jsonl files for sessions not listed in any index
       (handles newer Claude Code versions that stopped updating
       the index, or projects that never had one).

    Returns a flat list of session dicts.
    """
    sessions = []
    known_ids = set()

    # Pass 1: sessions-index.json (authoritative when present)
    for idx_path in glob.glob(SESSIONS_GLOB):
        try:
            with open(idx_path) as f:
                data = json.load(f)
        except (json.JSONDecodeError, IOError):
            continue
        for entry in data.get("entries", []):
            sessions.append(entry)
            sid = entry.get("sessionId", "")
            if sid:
                known_ids.add(sid)

    # Pass 2: .jsonl files not already in an index
    jsonl_sessions = _load_sessions_from_jsonl(known_ids)
    sessions.extend(jsonl_sessions)

    return sessions


def _extract_user_text(msg):
    """Pull plain text from a jsonl user message object."""
    if not isinstance(msg, dict):
        return ""
    content = msg.get("content", "")
    if isinstance(content, str):
        return content
    if isinstance(content, list):
        parts = []
        for c in content:
            if isinstance(c, dict) and c.get("type") == "text":
                parts.append(c.get("text", ""))
        return " ".join(parts)
    return ""


def _extract_jsonl_metadata(jsonl_path, session_id):
    """Read first lines of a .jsonl to extract session metadata.

    Only reads the first ~50 lines to stay fast on large files.
    Uses file mtime for the modified timestamp.
    """
    try:
        stat = os.stat(jsonl_path)
    except OSError:
        return None

    cwd = None
    git_branch = ""
    first_ts = None
    first_prompt = None
    msg_count = 0

    try:
        with open(jsonl_path) as f:
            for i, line in enumerate(f):
                if i > 50:
                    break
                try:
                    obj = json.loads(line)
                except (json.JSONDecodeError, ValueError):
                    continue

                t = obj.get("type", "")

                if not cwd and "cwd" in obj:
                    cwd = obj["cwd"]
                if not git_branch and obj.get("gitBranch"):
                    git_branch = obj["gitBranch"]
                if not first_ts and "timestamp" in obj:
                    first_ts = obj["timestamp"]

                if t == "user":
                    msg_count += 1
                    if not first_prompt:
                        text = _extract_user_text(obj.get("message", {}))
                        # Skip /init command messages
                        if "command-message" not in text and text.strip():
                            first_prompt = text.strip()
    except (IOError, OSError):
        return None

    if not cwd:
        return None

    # File mtime as ISO timestamp for the modified field
    modified = datetime.fromtimestamp(
        stat.st_mtime, tz=timezone.utc
    ).isoformat()

    return {
        "sessionId": session_id,
        "projectPath": cwd,
        "modified": modified,
        "created": first_ts or modified,
        "messageCount": msg_count,
        "firstPrompt": (first_prompt or "")[:200],
        "summary": "",
        "gitBranch": git_branch,
    }


def _load_sessions_from_jsonl(known_ids):
    """Scan .jsonl files for sessions missing from sessions-index.json.

    Walks every project directory under ~/.claude/projects/ and checks
    for .jsonl files whose session ID (the filename stem) is not already
    in known_ids. Extracts lightweight metadata from the first ~50 lines.
    """
    sessions = []
    if not os.path.isdir(PROJECTS_DIR):
        return sessions

    for project_dir in os.listdir(PROJECTS_DIR):
        full_dir = os.path.join(PROJECTS_DIR, project_dir)
        if not os.path.isdir(full_dir):
            continue
        try:
            entries = os.listdir(full_dir)
        except OSError:
            continue
        for fname in entries:
            if not fname.endswith(".jsonl"):
                continue
            session_id = fname[:-6]  # strip .jsonl
            if session_id in known_ids:
                continue

            jsonl_path = os.path.join(full_dir, fname)
            meta = _extract_jsonl_metadata(jsonl_path, session_id)
            if meta:
                sessions.append(meta)
                known_ids.add(session_id)

    return sessions


def format_date(iso_str):
    """Format an ISO 8601 timestamp to compact local time.

    Handles both "2024-01-15T10:30:00Z" and "2024-01-15T10:30:00+00:00"
    formats. Falls back gracefully if parsing fails.
    """
    if not iso_str:
        return "unknown"
    try:
        dt = datetime.fromisoformat(iso_str.replace("Z", "+00:00"))
        local = dt.astimezone()
        return local.strftime("%Y-%m-%d %H:%M")
    except (ValueError, TypeError):
        return iso_str[:16]


def short_project(path, aliases):
    """Shorten a project path for display using configured aliases.

    First replaces $HOME with ~, then applies each alias from config.
    Aliases are simple string prefix replacements applied in order.
    """
    if not path:
        return "?"
    # Collapse home directory to ~
    home = os.path.expanduser("~")
    if path.startswith(home):
        path = "~" + path[len(home):]
    # Apply configured aliases (order matters for overlapping prefixes)
    for long_prefix, short_prefix in aliases.items():
        path = path.replace(long_prefix, short_prefix)
    return path


def build_display_lines(sessions, aliases, custom_summaries=None,
                        search_snippets=None):
    """Build tab-separated display lines for fzf or --list output.

    Each line: sessionId <tab> date <tab> msgcount <tab> project <tab> summary
    In search mode, a 6th field contains the search snippet (for preview).

    Tab separation lets fzf treat each as a column with --delimiter.
    The summary is truncated to 60 chars to keep lines readable.
    Custom summaries (from summaries.json) override auto-generated ones.
    """
    if custom_summaries is None:
        custom_summaries = {}
    if search_snippets is None:
        search_snippets = {}
    lines = []
    for s in sessions:
        sid = s.get("sessionId", "?")
        date = format_date(s.get("modified"))
        msgs = str(s.get("messageCount", 0)).rjust(3)
        proj = short_project(s.get("projectPath", ""), aliases)
        # Custom summary wins over auto-generated
        if sid in custom_summaries:
            summary = custom_summaries[sid][:60]
        else:
            summary = (s.get("summary") or s.get("firstPrompt") or "")[:60]
        # Append git branch to project path if available
        branch = s.get("gitBranch", "")
        if branch:
            proj = f"{proj} ({branch})"
        line = f"{sid}\t{date}\t{msgs}m\t{proj}\t{summary}"
        # Append search snippets as hidden 6th field for preview
        if sid in search_snippets:
            snips = " | ".join(search_snippets[sid])
            line += f"\t{snips}"
        lines.append(line)
    return lines


def print_list(lines, count):
    """Print sessions in a formatted table (--list mode)."""
    print(f"{'ID':36s}  {'Modified':16s}  {'Msgs':>4s}  {'Project':40s}  Summary")
    print("-" * 120)
    for line in lines:
        parts = line.split("\t")
        print(f"{parts[0]:36s}  {parts[1]:16s}  {parts[2]:>4s}  {parts[3]:40s}  {parts[4]}")
    print(f"\n{count} sessions")


def edit_summary(session_id, current_summary):
    """Open $EDITOR (or vi) to edit a session summary. Returns new summary."""
    import tempfile
    editor = os.environ.get("EDITOR", "vi")
    with tempfile.NamedTemporaryFile(
        mode="w", suffix=".txt", prefix="claude-summary-", delete=False
    ) as tf:
        tf.write(current_summary)
        tf_path = tf.name
    try:
        subprocess.run([editor, tf_path])
        with open(tf_path) as f:
            new_summary = f.read().strip()
        # Collapse to single line
        new_summary = " ".join(new_summary.split())
        return new_summary
    finally:
        os.unlink(tf_path)


def pick_with_fzf(lines, search_mode=False):
    """Launch fzf with session lines and return the chosen line.

    Returns a tuple (action, line) where action is "select" or "edit",
    or (None, None) if the user cancelled (Esc / Ctrl-C).

    In search_mode, the preview shows matching snippets (field 6)
    instead of just metadata.
    """
    header = ("ID                                    Modified"
              "          Msgs  Project"
              "                                   Summary"
              "  [ctrl-e: edit summary]")
    # Wrap preview in sh -c so it runs in POSIX shell, not tcsh.
    # fzf substitutes {1}, {4}, etc. before passing to the shell,
    # and summaries can contain () which tcsh treats as subshells.
    if search_mode:
        preview_cmd = (
            "sh -c 'echo \"Session: {1}\" && echo \"Project: {4}\" && "
            "echo \"Summary: {5}\" && echo \"---\" && echo \"Matches: {6}\"'"
        )
        prompt = "search> "
    else:
        preview_cmd = (
            "sh -c 'echo \"Session: {1}\" && echo \"Project: {4}\" && "
            "echo \"Summary: {5}\"'"
        )
        prompt = "resume> "
    fzf_input = "\n".join(lines)
    try:
        result = subprocess.run(
            [
                "fzf",
                "--header", header,
                "--delimiter", "\t",
                "--with-nth", "1,2,3,4,5",
                "--tabstop", "2",
                "--preview-window", "down:5:wrap" if search_mode else "down:3:wrap",
                "--preview", preview_cmd,
                "--ansi",
                "--no-mouse",
                "--height", "80%",
                "--layout", "reverse",
                "--prompt", prompt,
                "--expect", "ctrl-e",
            ],
            input=fzf_input,
            capture_output=True,
            text=True,
        )
    except FileNotFoundError:
        print("fzf not found. Install with: brew install fzf", file=sys.stderr)
        sys.exit(1)

    if result.returncode != 0:
        return None, None  # user cancelled

    output_lines = result.stdout.split("\n")
    if len(output_lines) < 2:
        return None, None

    key = output_lines[0].strip()  # "" for enter, "ctrl-e" for edit
    chosen = output_lines[1].strip()

    if not chosen:
        return None, None

    if key == "ctrl-e":
        return "edit", chosen
    return "select", chosen


def main():
    parser = argparse.ArgumentParser(
        description="Global Claude Code session picker",
        epilog="Config: %(config)s" % {"config": CONFIG_FILE},
    )
    parser.add_argument(
        "-n", type=int, default=0,
        help="show only N most recent sessions",
    )
    parser.add_argument(
        "-d", "--days", type=float, default=0,
        help="show only sessions modified within the last N days",
    )
    parser.add_argument(
        "-q", type=str, default="",
        help="pre-filter: regex match on project path, summary, or first prompt",
    )
    parser.add_argument(
        "--list", action="store_true",
        help="print sessions as a table without launching fzf",
    )
    parser.add_argument(
        "--json", action="store_true",
        help="output raw JSON for the selected session (implies fzf)",
    )
    parser.add_argument(
        "--search", type=str, default="",
        help="full-text search across session content (user + assistant messages)",
    )
    parser.add_argument(
        "--reindex", action="store_true",
        help="force full rebuild of the search index",
    )
    args = parser.parse_args()

    # Load config (creates default on first run)
    config = load_config()
    aliases = config.get("path_aliases", {})

    # Load custom summary overrides
    custom_summaries = load_summaries()

    # Aggregate sessions from all projects
    sessions = load_all_sessions()

    # Most recently modified first
    sessions.sort(key=lambda s: s.get("modified", ""), reverse=True)

    # Full-text search mode (--search or --reindex)
    search_snippets = {}  # session_id -> [snippet, ...]
    if args.search or args.reindex:
        db = get_search_db(force_reindex=args.reindex)
        update_search_index(db)
        if args.reindex and not args.search:
            print("Reindex complete.", file=sys.stderr)
            db.close()
            sys.exit(0)
        search_snippets = search_sessions(db, args.search)
        db.close()
        if not search_snippets:
            print(f"No sessions match: {args.search}", file=sys.stderr)
            sys.exit(1)
        # Filter to only matching sessions, preserve search result order
        session_map = {s.get("sessionId"): s for s in sessions}
        sessions = [
            session_map[sid] for sid in search_snippets
            if sid in session_map
        ]

    # Optional time-based filter (--days / -d)
    if args.days > 0:
        from datetime import timedelta
        cutoff = datetime.now(timezone.utc) - timedelta(days=args.days)
        cutoff_iso = cutoff.isoformat()
        sessions = [
            s for s in sessions
            if s.get("modified", "") >= cutoff_iso
        ]

    # Optional regex pre-filter across project path, summary, and first prompt
    if args.q:
        import re
        pat = re.compile(args.q, re.IGNORECASE)
        sessions = [
            s for s in sessions
            if pat.search(s.get("projectPath", ""))
            or pat.search(s.get("summary", ""))
            or pat.search(s.get("firstPrompt", ""))
            or pat.search(custom_summaries.get(s.get("sessionId", ""), ""))
        ]

    # Optional limit
    if args.n > 0:
        sessions = sessions[:args.n]

    if not sessions:
        print("No sessions found.", file=sys.stderr)
        sys.exit(1)

    # Build display lines
    lines = build_display_lines(sessions, aliases, custom_summaries,
                                search_snippets)

    # --list mode: just print and exit
    if args.list:
        print_list(lines, len(lines))
        sys.exit(0)

    # Interactive mode: pick with fzf, loop on edits
    is_search = bool(search_snippets)
    while True:
        action, chosen_line = pick_with_fzf(lines, search_mode=is_search)
        if action is None:
            sys.exit(0)

        chosen_id = chosen_line.split("\t")[0].strip()

        if action == "edit":
            # Get current summary (custom or auto-generated)
            current = custom_summaries.get(chosen_id, "")
            if not current:
                s = next((s for s in sessions if s.get("sessionId") == chosen_id), {})
                current = s.get("summary") or s.get("firstPrompt") or ""
            new_summary = edit_summary(chosen_id, current)
            if new_summary != current:
                custom_summaries[chosen_id] = new_summary
                save_summaries(custom_summaries)
                # Rebuild lines with updated summary
                lines = build_display_lines(sessions, aliases, custom_summaries,
                                            search_snippets)
            continue  # re-open fzf

        # action == "select": resume the session
        break

    # Look up the full session entry to get projectPath
    chosen_session = next(
        (s for s in sessions if s.get("sessionId") == chosen_id),
        None,
    )
    if not chosen_session:
        print(f"Session {chosen_id} not found.", file=sys.stderr)
        sys.exit(1)

    # --json mode: dump and exit
    if args.json:
        print(json.dumps(chosen_session, indent=2))
        sys.exit(0)

    # Resume the session via claude CLI
    project_path = chosen_session.get("projectPath", "")
    summary = custom_summaries.get(chosen_id) or chosen_session.get("summary", chosen_id)
    print(f"\nResuming: {summary}")
    print(f"Project:  {project_path}")
    print(f"Command:  claude --resume {chosen_id}\n")

    # cd to project directory first - claude --resume resolves sessions
    # based on cwd, not the -p flag
    if project_path and os.path.isdir(project_path):
        os.chdir(project_path)
    else:
        print(f"Warning: project directory not found: {project_path}", file=sys.stderr)
        print("The session's project may have been deleted.", file=sys.stderr)
        sys.exit(1)

    # execvp replaces this process with claude
    os.execvp("claude", ["claude", "--resume", chosen_id])


if __name__ == "__main__":
    main()
