#!/usr/bin/env python3
"""
claude-sessions - Global Claude Code session picker.

Aggregates session metadata from all projects stored by Claude Code
in ~/.claude/projects/, presents them in fzf for interactive selection,
and resumes the chosen session with `claude --resume`.

Claude Code stores sessions per-project in:
    ~/.claude/projects/<mangled-path>/

where <mangled-path> is the absolute project path with / replaced by -.
Each project directory may contain:
  - sessions-index.json: a manifest with session metadata (sessionId,
    summary, modified date, message count, git branch, etc.)
  - {session-id}.jsonl: raw session transcript files

Older versions of Claude Code maintained sessions-index.json reliably,
but newer versions (circa late Jan 2026+) may not update it. This tool
handles both cases: it reads sessions-index.json when available, then
scans .jsonl files to discover any sessions not listed in an index.

This tool merges ALL sessions across ALL projects into one searchable
list, solving the problem that `claude --resume` only shows sessions
for the current working directory.

Path aliases:
    Long project paths are shortened for display using aliases loaded
    from ~/.config/claude-sessions/config.json. If the config file
    doesn't exist, a default one is created with a single universal
    alias (/private/tmp/ -> /tmp/, which is a macOS symlink artifact).

    Example config:
    {
        "path_aliases": {
            "/private/tmp/": "/tmp/"
        }
    }

    Add your own aliases to shorten paths you see often, e.g.:
    {
        "path_aliases": {
            "/private/tmp/": "/tmp/",
            "~/Projects/work/": "~/W/",
            "~/Documents/research/": "~/R/"
        }
    }

Usage:
    claude-sessions            # interactive fzf picker (all sessions)
    claude-sessions -n 50      # show only 50 most recent
    claude-sessions -q "regex" # pre-filter by project or summary
    claude-sessions --list     # just print, no fzf
    claude-sessions --json     # output JSON for the selected session

Keybindings (in fzf):
    Enter     Resume the selected session
    ctrl-e    Edit the summary of the selected session (opens $EDITOR)

Custom summaries:
    Edited summaries are stored in ~/.config/claude-sessions/summaries.json
    as a {sessionId: summary} map. These override auto-generated summaries
    from sessions-index.json and are preserved across runs.

Dependencies:
    - fzf (brew install fzf) for interactive mode
    - Python 3.7+ (for datetime.fromisoformat)
"""

import json
import glob
import os
import subprocess
import sys
import argparse
from datetime import datetime, timezone
from pathlib import Path

# XDG-conventional config location
CONFIG_DIR = os.path.expanduser("~/.config/claude-sessions")
CONFIG_FILE = os.path.join(CONFIG_DIR, "config.json")
SUMMARIES_FILE = os.path.join(CONFIG_DIR, "summaries.json")

# Base directory for Claude Code project data
PROJECTS_DIR = os.path.expanduser("~/.claude/projects")

# Where Claude Code stores session indexes (one per project)
SESSIONS_GLOB = os.path.join(PROJECTS_DIR, "*/sessions-index.json")

# Default config: only includes universal, non-PII aliases.
# /private/tmp/ -> /tmp/ is a macOS thing: /tmp is a symlink to /private/tmp,
# but Claude Code stores the resolved path.
DEFAULT_CONFIG = {
    "path_aliases": {
        "/private/tmp/": "/tmp/"
    }
}


def load_config():
    """Load path aliases from config file, creating a default if absent.

    Returns a dict with a "path_aliases" key mapping long prefixes to
    short replacements. Aliases are applied in order, so put longer
    (more specific) prefixes first if they overlap.
    """
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE) as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: bad config at {CONFIG_FILE}: {e}", file=sys.stderr)
            return DEFAULT_CONFIG

    # First run: create default config
    os.makedirs(CONFIG_DIR, exist_ok=True)
    with open(CONFIG_FILE, "w") as f:
        json.dump(DEFAULT_CONFIG, f, indent=2)
        f.write("\n")
    return DEFAULT_CONFIG


def load_summaries():
    """Load custom summary overrides from summaries.json.

    Returns a dict mapping sessionId -> custom summary string.
    """
    if os.path.exists(SUMMARIES_FILE):
        try:
            with open(SUMMARIES_FILE) as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            return {}
    return {}


def save_summaries(summaries):
    """Write custom summary overrides to summaries.json."""
    os.makedirs(CONFIG_DIR, exist_ok=True)
    with open(SUMMARIES_FILE, "w") as f:
        json.dump(summaries, f, indent=2)
        f.write("\n")


def load_all_sessions():
    """Load and merge session entries from all projects.

    Two-pass approach:
    1. Read sessions-index.json files (fast, has clean summaries).
    2. Scan .jsonl files for sessions not listed in any index
       (handles newer Claude Code versions that stopped updating
       the index, or projects that never had one).

    Returns a flat list of session dicts.
    """
    sessions = []
    known_ids = set()

    # Pass 1: sessions-index.json (authoritative when present)
    for idx_path in glob.glob(SESSIONS_GLOB):
        try:
            with open(idx_path) as f:
                data = json.load(f)
        except (json.JSONDecodeError, IOError):
            continue
        for entry in data.get("entries", []):
            sessions.append(entry)
            sid = entry.get("sessionId", "")
            if sid:
                known_ids.add(sid)

    # Pass 2: .jsonl files not already in an index
    jsonl_sessions = _load_sessions_from_jsonl(known_ids)
    sessions.extend(jsonl_sessions)

    return sessions


def _extract_user_text(msg):
    """Pull plain text from a jsonl user message object."""
    if not isinstance(msg, dict):
        return ""
    content = msg.get("content", "")
    if isinstance(content, str):
        return content
    if isinstance(content, list):
        parts = []
        for c in content:
            if isinstance(c, dict) and c.get("type") == "text":
                parts.append(c.get("text", ""))
        return " ".join(parts)
    return ""


def _extract_jsonl_metadata(jsonl_path, session_id):
    """Read first lines of a .jsonl to extract session metadata.

    Only reads the first ~50 lines to stay fast on large files.
    Uses file mtime for the modified timestamp.
    """
    try:
        stat = os.stat(jsonl_path)
    except OSError:
        return None

    cwd = None
    git_branch = ""
    first_ts = None
    first_prompt = None
    msg_count = 0

    try:
        with open(jsonl_path) as f:
            for i, line in enumerate(f):
                if i > 50:
                    break
                try:
                    obj = json.loads(line)
                except (json.JSONDecodeError, ValueError):
                    continue

                t = obj.get("type", "")

                if not cwd and "cwd" in obj:
                    cwd = obj["cwd"]
                if not git_branch and obj.get("gitBranch"):
                    git_branch = obj["gitBranch"]
                if not first_ts and "timestamp" in obj:
                    first_ts = obj["timestamp"]

                if t == "user":
                    msg_count += 1
                    if not first_prompt:
                        text = _extract_user_text(obj.get("message", {}))
                        # Skip /init command messages
                        if "command-message" not in text and text.strip():
                            first_prompt = text.strip()
    except (IOError, OSError):
        return None

    if not cwd:
        return None

    # File mtime as ISO timestamp for the modified field
    modified = datetime.fromtimestamp(
        stat.st_mtime, tz=timezone.utc
    ).isoformat()

    return {
        "sessionId": session_id,
        "projectPath": cwd,
        "modified": modified,
        "created": first_ts or modified,
        "messageCount": msg_count,
        "firstPrompt": (first_prompt or "")[:200],
        "summary": "",
        "gitBranch": git_branch,
    }


def _load_sessions_from_jsonl(known_ids):
    """Scan .jsonl files for sessions missing from sessions-index.json.

    Walks every project directory under ~/.claude/projects/ and checks
    for .jsonl files whose session ID (the filename stem) is not already
    in known_ids. Extracts lightweight metadata from the first ~50 lines.
    """
    sessions = []
    if not os.path.isdir(PROJECTS_DIR):
        return sessions

    for project_dir in os.listdir(PROJECTS_DIR):
        full_dir = os.path.join(PROJECTS_DIR, project_dir)
        if not os.path.isdir(full_dir):
            continue
        try:
            entries = os.listdir(full_dir)
        except OSError:
            continue
        for fname in entries:
            if not fname.endswith(".jsonl"):
                continue
            session_id = fname[:-6]  # strip .jsonl
            if session_id in known_ids:
                continue

            jsonl_path = os.path.join(full_dir, fname)
            meta = _extract_jsonl_metadata(jsonl_path, session_id)
            if meta:
                sessions.append(meta)
                known_ids.add(session_id)

    return sessions


def format_date(iso_str):
    """Format an ISO 8601 timestamp to compact local time.

    Handles both "2024-01-15T10:30:00Z" and "2024-01-15T10:30:00+00:00"
    formats. Falls back gracefully if parsing fails.
    """
    if not iso_str:
        return "unknown"
    try:
        dt = datetime.fromisoformat(iso_str.replace("Z", "+00:00"))
        local = dt.astimezone()
        return local.strftime("%Y-%m-%d %H:%M")
    except (ValueError, TypeError):
        return iso_str[:16]


def short_project(path, aliases):
    """Shorten a project path for display using configured aliases.

    First replaces $HOME with ~, then applies each alias from config.
    Aliases are simple string prefix replacements applied in order.
    """
    if not path:
        return "?"
    # Collapse home directory to ~
    home = os.path.expanduser("~")
    if path.startswith(home):
        path = "~" + path[len(home):]
    # Apply configured aliases (order matters for overlapping prefixes)
    for long_prefix, short_prefix in aliases.items():
        path = path.replace(long_prefix, short_prefix)
    return path


def build_display_lines(sessions, aliases, custom_summaries=None):
    """Build tab-separated display lines for fzf or --list output.

    Each line: sessionId <tab> date <tab> msgcount <tab> project <tab> summary

    Tab separation lets fzf treat each as a column with --delimiter.
    The summary is truncated to 60 chars to keep lines readable.
    Custom summaries (from summaries.json) override auto-generated ones.
    """
    if custom_summaries is None:
        custom_summaries = {}
    lines = []
    for s in sessions:
        sid = s.get("sessionId", "?")
        date = format_date(s.get("modified"))
        msgs = str(s.get("messageCount", 0)).rjust(3)
        proj = short_project(s.get("projectPath", ""), aliases)
        # Custom summary wins over auto-generated
        if sid in custom_summaries:
            summary = custom_summaries[sid][:60]
        else:
            summary = (s.get("summary") or s.get("firstPrompt") or "")[:60]
        # Append git branch to project path if available
        branch = s.get("gitBranch", "")
        if branch:
            proj = f"{proj} ({branch})"
        line = f"{sid}\t{date}\t{msgs}m\t{proj}\t{summary}"
        lines.append(line)
    return lines


def print_list(lines, count):
    """Print sessions in a formatted table (--list mode)."""
    print(f"{'ID':36s}  {'Modified':16s}  {'Msgs':>4s}  {'Project':40s}  Summary")
    print("-" * 120)
    for line in lines:
        parts = line.split("\t")
        print(f"{parts[0]:36s}  {parts[1]:16s}  {parts[2]:>4s}  {parts[3]:40s}  {parts[4]}")
    print(f"\n{count} sessions")


def edit_summary(session_id, current_summary):
    """Open $EDITOR (or vi) to edit a session summary. Returns new summary."""
    import tempfile
    editor = os.environ.get("EDITOR", "vi")
    with tempfile.NamedTemporaryFile(
        mode="w", suffix=".txt", prefix="claude-summary-", delete=False
    ) as tf:
        tf.write(current_summary)
        tf_path = tf.name
    try:
        subprocess.run([editor, tf_path])
        with open(tf_path) as f:
            new_summary = f.read().strip()
        # Collapse to single line
        new_summary = " ".join(new_summary.split())
        return new_summary
    finally:
        os.unlink(tf_path)


def pick_with_fzf(lines):
    """Launch fzf with session lines and return the chosen line.

    Returns a tuple (action, line) where action is "select" or "edit",
    or (None, None) if the user cancelled (Esc / Ctrl-C).
    """
    header = ("ID                                    Modified"
              "          Msgs  Project"
              "                                   Summary"
              "  [ctrl-e: edit summary]")
    fzf_input = "\n".join(lines)
    try:
        result = subprocess.run(
            [
                "fzf",
                "--header", header,
                "--delimiter", "\t",
                "--with-nth", "1,2,3,4,5",
                "--tabstop", "2",
                "--preview-window", "down:3:wrap",
                "--preview",
                "echo 'Session: {1}' && echo 'Project: {4}' && echo 'Summary: {5}'",
                "--ansi",
                "--no-mouse",
                "--height", "80%",
                "--layout", "reverse",
                "--prompt", "resume> ",
                "--expect", "ctrl-e",
            ],
            input=fzf_input,
            capture_output=True,
            text=True,
        )
    except FileNotFoundError:
        print("fzf not found. Install with: brew install fzf", file=sys.stderr)
        sys.exit(1)

    if result.returncode != 0:
        return None, None  # user cancelled

    output_lines = result.stdout.strip().split("\n")
    if len(output_lines) < 2:
        return None, None

    key = output_lines[0].strip()  # "" for enter, "ctrl-e" for edit
    chosen = output_lines[1].strip()

    if not chosen:
        return None, None

    if key == "ctrl-e":
        return "edit", chosen
    return "select", chosen


def main():
    parser = argparse.ArgumentParser(
        description="Global Claude Code session picker",
        epilog="Config: %(config)s" % {"config": CONFIG_FILE},
    )
    parser.add_argument(
        "-n", type=int, default=0,
        help="show only N most recent sessions",
    )
    parser.add_argument(
        "-q", type=str, default="",
        help="pre-filter: regex match on project path, summary, or first prompt",
    )
    parser.add_argument(
        "--list", action="store_true",
        help="print sessions as a table without launching fzf",
    )
    parser.add_argument(
        "--json", action="store_true",
        help="output raw JSON for the selected session (implies fzf)",
    )
    args = parser.parse_args()

    # Load config (creates default on first run)
    config = load_config()
    aliases = config.get("path_aliases", {})

    # Load custom summary overrides
    custom_summaries = load_summaries()

    # Aggregate sessions from all projects
    sessions = load_all_sessions()

    # Most recently modified first
    sessions.sort(key=lambda s: s.get("modified", ""), reverse=True)

    # Optional regex pre-filter across project path, summary, and first prompt
    if args.q:
        import re
        pat = re.compile(args.q, re.IGNORECASE)
        sessions = [
            s for s in sessions
            if pat.search(s.get("projectPath", ""))
            or pat.search(s.get("summary", ""))
            or pat.search(s.get("firstPrompt", ""))
            or pat.search(custom_summaries.get(s.get("sessionId", ""), ""))
        ]

    # Optional limit
    if args.n > 0:
        sessions = sessions[:args.n]

    if not sessions:
        print("No sessions found.", file=sys.stderr)
        sys.exit(1)

    # Build display lines
    lines = build_display_lines(sessions, aliases, custom_summaries)

    # --list mode: just print and exit
    if args.list:
        print_list(lines, len(lines))
        sys.exit(0)

    # Interactive mode: pick with fzf, loop on edits
    while True:
        action, chosen_line = pick_with_fzf(lines)
        if action is None:
            sys.exit(0)

        chosen_id = chosen_line.split("\t")[0].strip()

        if action == "edit":
            # Get current summary (custom or auto-generated)
            current = custom_summaries.get(chosen_id, "")
            if not current:
                s = next((s for s in sessions if s.get("sessionId") == chosen_id), {})
                current = s.get("summary") or s.get("firstPrompt") or ""
            new_summary = edit_summary(chosen_id, current)
            if new_summary != current:
                custom_summaries[chosen_id] = new_summary
                save_summaries(custom_summaries)
                # Rebuild lines with updated summary
                lines = build_display_lines(sessions, aliases, custom_summaries)
            continue  # re-open fzf

        # action == "select": resume the session
        break

    # Look up the full session entry to get projectPath
    chosen_session = next(
        (s for s in sessions if s.get("sessionId") == chosen_id),
        None,
    )
    if not chosen_session:
        print(f"Session {chosen_id} not found.", file=sys.stderr)
        sys.exit(1)

    # --json mode: dump and exit
    if args.json:
        print(json.dumps(chosen_session, indent=2))
        sys.exit(0)

    # Resume the session via claude CLI
    project_path = chosen_session.get("projectPath", "")
    summary = custom_summaries.get(chosen_id) or chosen_session.get("summary", chosen_id)
    print(f"\nResuming: {summary}")
    print(f"Project:  {project_path}")
    print(f"Command:  claude --resume {chosen_id}\n")

    # cd to project directory first - claude --resume resolves sessions
    # based on cwd, not the -p flag
    if project_path and os.path.isdir(project_path):
        os.chdir(project_path)
    else:
        print(f"Warning: project directory not found: {project_path}", file=sys.stderr)
        print("The session's project may have been deleted.", file=sys.stderr)
        sys.exit(1)

    # execvp replaces this process with claude
    os.execvp("claude", ["claude", "--resume", chosen_id])


if __name__ == "__main__":
    main()
