#!/Users/wiggins/mise/py/.venv/bin/python3
"""
Gmail CLI: list, read, send, and draft messages via Gmail API.

Usage:
    gmails                              # list 20 most recent messages
    gmails -n 5                         # list 5 most recent
    gmails -q "from:alice"              # list with Gmail search filter
    gmails -q "in:sent" -n 5            # list 5 most recent sent messages
    gmails 3                            # download message #3 to stdout
    gmails 3 message.eml               # download message #3 to file
    gmails 3 /tmp/                      # download to dir with auto-generated name

    gmails send user@ex.com -s "hi"     # send (body from stdin)
    gmails send -H msg.eml              # send a pre-built .eml
    gmails send user@ex.com             # interactive (opens $EDITOR)
    gmails send user@ex.com -s "hi" -a file.pdf  # send with attachment

    gmails draft user@ex.com -s "hi"    # save to Gmail Drafts (body from stdin)
    gmails draft -H msg.eml             # draft from .eml file
    gmails draft user@ex.com            # interactive draft (opens $EDITOR)

Designed for the !! workflow:
    % gmails -n 5 -q "from:alice"       # see the list
    % !! 3 reply.eml                    # expands to: gmails -n 5 -q "from:alice" 3 reply.eml
"""

import argparse
import base64
import email
import html as html_mod
import json
import mimetypes
import os
import re
import subprocess
import sys
import tempfile
import webbrowser
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.utils import getaddresses, parseaddr, parsedate_to_datetime
from pathlib import Path

from google_auth import get_credentials
from googleapiclient.discovery import build


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def parse_sender(from_header):
    """Extract a display-friendly sender from a From header."""
    if not from_header:
        return "(unknown)"
    name, addr = parseaddr(from_header)
    return name if name else addr


def parse_date(date_header):
    """Parse email Date header to YYYY-MM-DD string."""
    if not date_header:
        return "          "
    try:
        dt = parsedate_to_datetime(date_header)
        return dt.strftime("%Y-%m-%d")
    except Exception:
        return date_header[:10]


def get_header(headers, name):
    """Extract a header value from Gmail metadata headers list."""
    for h in headers:
        if h["name"].lower() == name.lower():
            return h["value"]
    return ""


def sanitize_filename(s, max_len=60):
    """Sanitize a string for use as a filename component."""
    s = re.sub(r"[^\w\s.-]", "", s)
    s = re.sub(r"\s+", "-", s.strip())
    s = re.sub(r"-+", "-", s)
    return s[:max_len].rstrip("-")


def generate_filename(raw_bytes):
    """Generate a filename from the email's Date, From, and Subject headers."""
    msg = email.message_from_bytes(raw_bytes, policy=email.policy.default)

    date_str = "unknown-date"
    date_hdr = msg.get("Date", "")
    if date_hdr:
        try:
            dt = parsedate_to_datetime(date_hdr)
            date_str = dt.strftime("%Y-%m-%d")
        except Exception:
            pass

    _, addr = parseaddr(msg.get("From", ""))
    from_part = sanitize_filename(addr.split("@")[0] if addr else "unknown", 20)

    subj = msg.get("Subject", "no-subject")
    subj_part = sanitize_filename(subj, 30)

    return f"{date_str}-{from_part}-{subj_part}.eml"


def versioned_path(path):
    """If path exists, move it to path-v1.ext (or path-v{N+1}.ext) and return original path."""
    if not path.exists():
        return path
    stem = path.stem
    suffix = path.suffix
    parent = path.parent

    # Find the highest existing version
    max_v = 0
    for sibling in parent.iterdir():
        m = re.match(re.escape(stem) + r"-v(\d+)" + re.escape(suffix) + "$", sibling.name)
        if m:
            max_v = max(max_v, int(m.group(1)))

    new_v = max_v + 1
    versioned = parent / f"{stem}-v{new_v}{suffix}"
    path.rename(versioned)
    print(f"Moved: {path.name} -> {versioned.name}", file=sys.stderr)
    return path


def save_attachments(raw_bytes, output_dir):
    """Extract and save attachments alongside the .eml file."""
    msg = email.message_from_bytes(raw_bytes, policy=email.policy.default)
    saved = []

    for part in msg.walk():
        disp = part.get("Content-Disposition", "")
        if "attachment" not in disp:
            continue

        filename = part.get_filename()
        if not filename:
            filename = f"attachment-{len(saved) + 1}.bin"

        att_path = output_dir / filename
        if att_path.exists():
            print(f"Attachment already exists, skipping: {att_path}", file=sys.stderr)
            continue

        payload = part.get_payload(decode=True)
        if payload:
            att_path.write_bytes(payload)
            saved.append(att_path)

    return saved


LAST_LIST_CACHE = Path("/tmp/spool/.gmails-last-list.json")


def _cache_message_ids(messages, count, query, account=None):
    """Save message list to cache for !! workflow safety."""
    LAST_LIST_CACHE.parent.mkdir(exist_ok=True)
    data = {
        "count": count,
        "query": query,
        "account": account,
        "messages": [{"id": m["id"], "threadId": m.get("threadId", "")} for m in messages],
    }
    LAST_LIST_CACHE.write_text(json.dumps(data))


def _load_cached_ids(count, query, account=None):
    """Load cached message IDs if they match current query params and account.

    Returns list of message dicts, or None if no valid cache.
    """
    if not LAST_LIST_CACHE.exists():
        return None
    try:
        data = json.loads(LAST_LIST_CACHE.read_text())
        if (data.get("count") == count and data.get("query") == query
                and data.get("account") == account):
            return data["messages"]
    except (json.JSONDecodeError, KeyError):
        pass
    return None


def _strip_html(html_text):
    """Crude HTML-to-text: strip tags, decode entities, collapse whitespace."""
    # Remove style and script blocks
    text = re.sub(r"<(style|script)[^>]*>.*?</\1>", "", html_text, flags=re.DOTALL | re.IGNORECASE)
    # Block elements get newlines
    text = re.sub(r"<(br|p|div|tr|li|h[1-6])[^>]*>", "\n", text, flags=re.IGNORECASE)
    # Strip remaining tags
    text = re.sub(r"<[^>]+>", "", text)
    # Decode HTML entities
    text = html_mod.unescape(text)
    # Collapse runs of blank lines
    text = re.sub(r"\n{3,}", "\n\n", text)
    return text.strip()


def extract_text_body(raw_bytes):
    """Extract text/plain body from raw email bytes, falling back to stripped HTML."""
    msg = email.message_from_bytes(raw_bytes, policy=email.policy.default)
    html_fallback = None

    def _check_part(part):
        nonlocal html_fallback
        ct = part.get_content_type()
        if ct == "text/plain":
            charset = part.get_content_charset() or "utf-8"
            return part.get_payload(decode=True).decode(charset, errors="replace")
        if ct == "text/html" and html_fallback is None:
            charset = part.get_content_charset() or "utf-8"
            html_fallback = part.get_payload(decode=True).decode(charset, errors="replace")
        return None

    if msg.is_multipart():
        for part in msg.walk():
            result = _check_part(part)
            if result is not None:
                return result
    else:
        result = _check_part(msg)
        if result is not None:
            return result

    if html_fallback:
        return _strip_html(html_fallback)
    return "(no message body found)"


ACCOUNTS_FILE = Path("~/.config/gmails/accounts").expanduser()


def do_list_accounts():
    """Print configured accounts from ~/.config/gmails/accounts."""
    if not ACCOUNTS_FILE.exists():
        print(f"No accounts file at {ACCOUNTS_FILE}", file=sys.stderr)
        print("Create it with lines like: user@example.com /path/to/muttrc", file=sys.stderr)
        sys.exit(1)
    with open(ACCOUNTS_FILE) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split(None, 1)
            if len(parts) == 2:
                print(f"  {parts[0]}")
    sys.exit(0)


def resolve_account(config_path, email_addr, scope_prefix):
    """Resolve account from -F config file or -e email address.

    Returns (token_name, login_hint) tuple, or (None, None) if neither given.
    """
    # Fall back to GMAILS_ACCOUNT env var if neither -F nor -e given
    if not email_addr and not config_path:
        email_addr = os.environ.get("GMAILS_ACCOUNT")
    if email_addr:
        # -e flag: look up config path from accounts file, derive token name
        full_email, config_path = _lookup_config_for_email(email_addr)
        acct = full_email.replace("@", "-at-").replace(".", "-")
        return f"{scope_prefix}-{acct}", full_email
    if config_path:
        # -F flag: extract email from muttrc
        with open(config_path) as f:
            for line in f:
                m = re.match(r'^set\s+imap_user\s*=\s*"(.+?)"', line)
                if m:
                    found_email = m.group(1)
                    acct = found_email.replace("@", "-at-").replace(".", "-")
                    return f"{scope_prefix}-{acct}", found_email
        print(f"No imap_user found in {config_path}", file=sys.stderr)
        sys.exit(1)
    return None, None


def _lookup_config_for_email(email_addr):
    """Find muttrc config path for an email address from ~/.config/gmails/accounts.

    Supports partial matching (e.g., 'lakedutchess' matches 'chris@lakedutchess.com').
    Returns (full_email, config_path) tuple.
    """
    if not ACCOUNTS_FILE.exists():
        print(f"No accounts file at {ACCOUNTS_FILE}", file=sys.stderr)
        print("Create it with lines like: user@example.com /path/to/muttrc", file=sys.stderr)
        sys.exit(1)

    matches = []
    with open(ACCOUNTS_FILE) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split(None, 1)
            if len(parts) != 2:
                continue
            acct_email, acct_path = parts
            if email_addr in acct_email:
                matches.append((acct_email, acct_path))

    if len(matches) == 1:
        return matches[0]
    if len(matches) == 0:
        print(f"No account matching '{email_addr}' in {ACCOUNTS_FILE}", file=sys.stderr)
        sys.exit(1)
    print(f"Ambiguous: '{email_addr}' matches multiple accounts:", file=sys.stderr)
    for acct_email, _ in matches:
        print(f"  {acct_email}", file=sys.stderr)
    sys.exit(1)


def get_body_interactive(recipient, subject):
    """Open $EDITOR and return the body text."""
    editor = os.environ.get("EDITOR", "vim")
    with tempfile.NamedTemporaryFile(suffix=".txt", mode="w", delete=False) as f:
        tmpfile = f.name
    try:
        subprocess.call([editor, tmpfile])
        body = Path(tmpfile).read_text()
    finally:
        os.unlink(tmpfile)
    if not body.strip():
        print("Empty body, aborting.", file=sys.stderr)
        sys.exit(1)
    return body


def build_mime_message(recipient, subject, body, cc=None, bcc=None, attachments=None):
    """Build a MIME message from parts. Returns bytes."""
    msg = MIMEText(body, "plain", "utf-8")
    msg["To"] = recipient
    if subject:
        msg["Subject"] = subject
    if cc:
        msg["Cc"] = cc
    if bcc:
        msg["Bcc"] = bcc
    msg = _attach_files(msg, attachments)
    return msg.as_bytes()


# ---------------------------------------------------------------------------
# List mode
# ---------------------------------------------------------------------------

def do_list(service, count, query, account=None):
    """List recent messages as a numbered table."""
    kwargs = {"userId": "me", "maxResults": count}
    if query:
        kwargs["q"] = query
    result = service.users().messages().list(**kwargs).execute()
    messages = result.get("messages", [])

    if not messages:
        print("No messages found.", file=sys.stderr)
        sys.exit(0)

    # Cache message IDs for !! workflow safety
    _cache_message_ids(messages, count, query, account=account)

    try:
        term_width = os.get_terminal_size().columns
    except OSError:
        term_width = 80

    # Batch-fetch metadata for all messages (1 HTTP round-trip instead of N)
    fetched = [None] * len(messages)

    def _make_callback(idx):
        def _cb(req_id, response, exception):
            if exception is None:
                fetched[idx] = response
        return _cb

    batch = service.new_batch_http_request()
    for i, msg_stub in enumerate(messages):
        batch.add(
            service.users().messages().get(
                userId="me",
                id=msg_stub["id"],
                format="metadata",
                metadataHeaders=["From", "Subject", "Date"],
            ),
            callback=_make_callback(i),
        )
    batch.execute()

    idx_width = len(str(len(messages)))
    from_width = 25
    # +2 for unread marker "* " or "  "
    fixed_width = idx_width + 1 + 2 + 10 + 2 + from_width + 2
    subj_width = max(term_width - fixed_width, 10)

    unread_count = 0
    for i, msg in enumerate(fetched, 1):
        if msg is None:
            print(f"{i:>{idx_width}}.  (fetch error)")
            continue

        headers = msg.get("payload", {}).get("headers", [])
        date_str = parse_date(get_header(headers, "Date"))
        sender = parse_sender(get_header(headers, "From"))
        subject = get_header(headers, "Subject") or "(no subject)"
        unread = "UNREAD" in msg.get("labelIds", [])
        if unread:
            unread_count += 1

        if len(sender) > from_width:
            sender = sender[: from_width - 1] + "\u2026"
        if len(subject) > subj_width:
            subject = subject[: subj_width - 1] + "\u2026"

        marker = "*" if unread else " "
        print(f"{i:>{idx_width}}.{marker}{date_str}  {sender:<{from_width}}  {subject}")

    # Enhancement 5: summary line
    if unread_count:
        print(f"  ({unread_count} unread / {len(messages)} shown)", file=sys.stderr)


# ---------------------------------------------------------------------------
# Get mode
# ---------------------------------------------------------------------------

def _resolve_message_id(service, index, count, query, account=None):
    """Resolve a 1-based index to a Gmail message ID, using cache when safe."""
    # Try cache first (!! workflow: same count+query+account means same list)
    cached = _load_cached_ids(count, query, account=account)
    if cached and 1 <= index <= len(cached):
        return cached[index - 1]["id"]

    # Cache miss or stale: fetch fresh
    kwargs = {"userId": "me", "maxResults": count}
    if query:
        kwargs["q"] = query
    result = service.users().messages().list(**kwargs).execute()
    messages = result.get("messages", [])

    if not messages:
        print("No messages found.", file=sys.stderr)
        sys.exit(1)

    if index < 1 or index > len(messages):
        print(f"Index {index} out of range (1-{len(messages)}).", file=sys.stderr)
        sys.exit(1)

    # Update cache
    _cache_message_ids(messages, count, query, account=account)
    return messages[index - 1]["id"]


def do_get(service, index, count, query, output, stdout=False, text_view=False, account=None):
    """Download a message by its 1-based index."""
    msg_id = _resolve_message_id(service, index, count, query, account=account)

    raw_msg = service.users().messages().get(
        userId="me", id=msg_id, format="raw"
    ).execute()
    raw_bytes = base64.urlsafe_b64decode(raw_msg["raw"])

    # -t flag: extract and print text body (with HTML fallback)
    if text_view:
        msg = email.message_from_bytes(raw_bytes, policy=email.policy.default)
        sender = msg.get("From", "unknown")
        subject = msg.get("Subject", "(no subject)")
        date = msg.get("Date", "")
        print(f"From: {sender}", file=sys.stderr)
        print(f"Date: {date}", file=sys.stderr)
        print(f"Subject: {subject}", file=sys.stderr)
        print("---", file=sys.stderr)
        print(extract_text_body(raw_bytes))
        # Mark as read
        service.users().messages().modify(
            userId="me", id=msg_id,
            body={"removeLabelIds": ["UNREAD"]},
        ).execute()
        return

    # -S flag: raw to stdout for piping
    if stdout:
        sys.stdout.buffer.write(raw_bytes)
        return

    # Determine output path
    if output is None:
        # No output arg: save to /tmp/spool (a la /var/spool/mail)
        spool = Path("/tmp/spool")
        spool.mkdir(exist_ok=True)
        output_path = spool / generate_filename(raw_bytes)
    else:
        output_path = Path(output)
        if output_path.is_dir():
            output_path = output_path / generate_filename(raw_bytes)

    # Version existing file instead of erroring
    output_path = versioned_path(output_path)

    output_path.write_bytes(raw_bytes)

    msg = email.message_from_bytes(raw_bytes, policy=email.policy.default)
    sender = msg.get("From", "unknown")
    subject = msg.get("Subject", "(no subject)")

    attachments = save_attachments(raw_bytes, output_path.parent)

    att_note = f" + {len(attachments)} attachment(s)" if attachments else ""
    print(f"Saved: {output_path} (From: {sender}, Subject: {subject}){att_note}", file=sys.stderr)


# ---------------------------------------------------------------------------
# Reply mode
# ---------------------------------------------------------------------------

def do_reply(service, index, count, query, args, as_draft=False, account=None):
    """Download message by index, extract headers, open $EDITOR for reply."""
    msg_id = _resolve_message_id(service, index, count, query, account=account)
    raw_msg = service.users().messages().get(
        userId="me", id=msg_id, format="raw"
    ).execute()
    raw_bytes = base64.urlsafe_b64decode(raw_msg["raw"])
    msg = email.message_from_bytes(raw_bytes, policy=email.policy.default)

    # Extract headers for reply
    orig_from = msg.get("From", "")
    orig_subject = msg.get("Subject", "")
    orig_msg_id = msg.get("Message-ID", "")
    orig_references = msg.get("References", "")
    orig_date = msg.get("Date", "")

    # Reply-To takes precedence over From
    reply_to = msg.get("Reply-To", orig_from)
    _, reply_addr = parseaddr(reply_to)

    # Reply-all: collect To and Cc, excluding our own address
    reply_all = getattr(args, 'all', False)
    cc_addrs = ""
    if reply_all:
        all_recipients = set()
        for hdr_name in ("To", "Cc"):
            hdr_val = msg.get(hdr_name, "")
            if hdr_val:
                for _, addr in getaddresses([hdr_val]):
                    if addr and addr.lower() != reply_addr.lower():
                        # Exclude ourselves (account or best guess from login_hint)
                        if account and addr.lower() == account.lower():
                            continue
                        all_recipients.add(addr)
        if all_recipients:
            cc_addrs = ", ".join(sorted(all_recipients))

    # Build Re: subject
    re_subject = orig_subject
    if not re_subject.lower().startswith("re:"):
        re_subject = f"Re: {orig_subject}"

    # Build References chain
    refs = orig_references
    if orig_msg_id:
        refs = f"{refs} {orig_msg_id}".strip()

    # Quote original body
    orig_body = ""
    if msg.is_multipart():
        for part in msg.walk():
            if part.get_content_type() == "text/plain":
                charset = part.get_content_charset() or "utf-8"
                orig_body = part.get_payload(decode=True).decode(charset, errors="replace")
                break
    else:
        charset = msg.get_content_charset() or "utf-8"
        orig_body = msg.get_payload(decode=True).decode(charset, errors="replace")

    _, orig_name = parseaddr(orig_from)
    quoted = "\n".join(f"> {line}" for line in orig_body.splitlines())
    template = f"\n\nOn {orig_date}, {orig_name} wrote:\n{quoted}\n"

    # Stdin body or interactive editor
    if not sys.stdin.isatty():
        body = sys.stdin.read() + template
    else:
        editor = os.environ.get("EDITOR", "vim")
        with tempfile.NamedTemporaryFile(suffix=".txt", mode="w", delete=False) as f:
            f.write(template)
            tmpfile = f.name
        try:
            subprocess.call([editor, tmpfile])
            body = Path(tmpfile).read_text()
        finally:
            os.unlink(tmpfile)

    if not body.strip():
        print("Empty body, aborting.", file=sys.stderr)
        sys.exit(1)

    # Build reply message
    reply = MIMEText(body, "plain", "utf-8")
    reply["To"] = reply_addr
    if cc_addrs:
        reply["Cc"] = cc_addrs
    reply["Subject"] = re_subject
    if orig_msg_id:
        reply["In-Reply-To"] = orig_msg_id
    if refs:
        reply["References"] = refs

    reply = _attach_files(reply, getattr(args, 'attach', None))
    raw_reply = base64.urlsafe_b64encode(reply.as_bytes()).decode()

    if as_draft:
        result = service.users().drafts().create(
            userId="me", body={"message": {"raw": raw_reply}}
        ).execute()
        print(f"Draft reply saved: To={reply_addr} Subject={re_subject} id={result.get('id', '?')}", file=sys.stderr)
    else:
        result = service.users().messages().send(
            userId="me", body={"raw": raw_reply}
        ).execute()
        print(f"Sent reply: To={reply_addr} Subject={re_subject} id={result.get('id', '?')}", file=sys.stderr)


# ---------------------------------------------------------------------------
# Forward mode
# ---------------------------------------------------------------------------

def do_forward(service, index, count, query, recipient, subject_override=None, as_draft=False, account=None):
    """Forward a message by index to a new recipient."""
    msg_id = _resolve_message_id(service, index, count, query, account=account)
    raw_msg = service.users().messages().get(
        userId="me", id=msg_id, format="raw"
    ).execute()
    raw_bytes = base64.urlsafe_b64decode(raw_msg["raw"])
    orig = email.message_from_bytes(raw_bytes, policy=email.policy.default)

    orig_subject = orig.get("Subject", "")
    orig_from = orig.get("From", "")
    orig_date = orig.get("Date", "")
    orig_msg_id = orig.get("Message-ID", "")

    fwd_subject = subject_override or (
        orig_subject if orig_subject.lower().startswith("fwd:") else f"Fwd: {orig_subject}"
    )

    # Extract original text body for inline quote
    orig_body = extract_text_body(raw_bytes)
    fwd_header = f"---------- Forwarded message ----------\nFrom: {orig_from}\nDate: {orig_date}\nSubject: {orig_subject}\n\n"
    template = f"\n\n{fwd_header}{orig_body}\n"

    # Stdin body or interactive editor
    if not sys.stdin.isatty():
        body = sys.stdin.read() + template
    else:
        editor = os.environ.get("EDITOR", "vim")
        with tempfile.NamedTemporaryFile(suffix=".txt", mode="w", delete=False) as f:
            f.write(template)
            tmpfile = f.name
        try:
            subprocess.call([editor, tmpfile])
            body = Path(tmpfile).read_text()
        finally:
            os.unlink(tmpfile)

    if not body.strip():
        print("Empty body, aborting.", file=sys.stderr)
        sys.exit(1)

    fwd = MIMEText(body, "plain", "utf-8")
    fwd["To"] = recipient
    fwd["Subject"] = fwd_subject
    if orig_msg_id:
        fwd["References"] = orig_msg_id

    # Carry over attachments from the original
    for part in orig.walk():
        disp = part.get("Content-Disposition", "")
        if "attachment" not in disp:
            continue
        filename = part.get_filename() or "attachment.bin"
        payload = part.get_payload(decode=True)
        if not payload:
            continue
        ctype = part.get_content_type() or "application/octet-stream"
        maintype, subtype = ctype.split("/", 1)
        att = MIMEBase(maintype, subtype)
        att.set_payload(payload)
        email.encoders.encode_base64(att)
        att.add_header("Content-Disposition", "attachment", filename=filename)
        # Need multipart wrapper
        if not fwd.is_multipart():
            text_part = MIMEText(fwd.get_payload(), "plain", "utf-8")
            fwd = MIMEMultipart()
            fwd["To"] = recipient
            fwd["Subject"] = fwd_subject
            if orig_msg_id:
                fwd["References"] = orig_msg_id
            fwd.attach(text_part)
        fwd.attach(att)

    raw_fwd = base64.urlsafe_b64encode(fwd.as_bytes()).decode()

    if as_draft:
        result = service.users().drafts().create(
            userId="me", body={"message": {"raw": raw_fwd}}
        ).execute()
        print(f"Draft forward saved: To={recipient} Subject={fwd_subject} id={result.get('id', '?')}", file=sys.stderr)
    else:
        result = service.users().messages().send(
            userId="me", body={"raw": raw_fwd}
        ).execute()
        print(f"Forwarded: To={recipient} Subject={fwd_subject} id={result.get('id', '?')}", file=sys.stderr)


# ---------------------------------------------------------------------------
# Trash mode
# ---------------------------------------------------------------------------

def do_trash(service, indices, count, query, account=None):
    """Move one or more messages to trash by 1-based index."""
    for index in indices:
        msg_id = _resolve_message_id(service, index, count, query, account=account)

        meta = service.users().messages().get(
            userId="me", id=msg_id, format="metadata",
            metadataHeaders=["From", "Subject"],
        ).execute()
        headers = meta.get("payload", {}).get("headers", [])
        sender = parse_sender(get_header(headers, "From"))
        subject = get_header(headers, "Subject") or "(no subject)"

        service.users().messages().trash(userId="me", id=msg_id).execute()
        print(f"Trashed: From={sender} Subject={subject}", file=sys.stderr)

    LAST_LIST_CACHE.unlink(missing_ok=True)


# ---------------------------------------------------------------------------
# Archive mode
# ---------------------------------------------------------------------------

def do_archive(service, indices, count, query, account=None):
    """Archive one or more messages (remove from inbox, keep in All Mail)."""
    for index in indices:
        msg_id = _resolve_message_id(service, index, count, query, account=account)

        meta = service.users().messages().get(
            userId="me", id=msg_id, format="metadata",
            metadataHeaders=["From", "Subject"],
        ).execute()
        headers = meta.get("payload", {}).get("headers", [])
        sender = parse_sender(get_header(headers, "From"))
        subject = get_header(headers, "Subject") or "(no subject)"

        service.users().messages().modify(
            userId="me", id=msg_id,
            body={"removeLabelIds": ["INBOX"]},
        ).execute()
        print(f"Archived: From={sender} Subject={subject}", file=sys.stderr)

    LAST_LIST_CACHE.unlink(missing_ok=True)


# ---------------------------------------------------------------------------
# Mark read/unread
# ---------------------------------------------------------------------------

def do_mark_read(service, indices, count, query, account=None):
    """Mark one or more messages as read."""
    for index in indices:
        msg_id = _resolve_message_id(service, index, count, query, account=account)
        service.users().messages().modify(
            userId="me", id=msg_id,
            body={"removeLabelIds": ["UNREAD"]},
        ).execute()
        print(f"Marked read: #{index}", file=sys.stderr)


def do_mark_unread(service, indices, count, query, account=None):
    """Mark one or more messages as unread."""
    for index in indices:
        msg_id = _resolve_message_id(service, index, count, query, account=account)
        service.users().messages().modify(
            userId="me", id=msg_id,
            body={"addLabelIds": ["UNREAD"]},
        ).execute()
        print(f"Marked unread: #{index}", file=sys.stderr)


# ---------------------------------------------------------------------------
# Open in browser
# ---------------------------------------------------------------------------

def do_open(service, index, count, query, account=None):
    """Open a message in Gmail web UI."""
    msg_id = _resolve_message_id(service, index, count, query, account=account)

    # Use authuser param so the browser picks the right account
    if account:
        url = f"https://mail.google.com/mail/?authuser={account}#inbox/{msg_id}"
    else:
        url = f"https://mail.google.com/mail/u/0/#inbox/{msg_id}"
    print(f"Opening: {url}", file=sys.stderr)
    webbrowser.open(url)


# ---------------------------------------------------------------------------
# Thread view
# ---------------------------------------------------------------------------

def do_thread(service, index, count, query, account=None):
    """Show all messages in the thread containing message at index."""
    msg_id = _resolve_message_id(service, index, count, query, account=account)

    # Get threadId from the message
    msg_meta = service.users().messages().get(
        userId="me", id=msg_id, format="metadata",
        metadataHeaders=["From", "Subject", "Date"],
    ).execute()
    thread_id = msg_meta.get("threadId")

    # Fetch the full thread
    thread = service.users().threads().get(
        userId="me", id=thread_id, format="metadata",
        metadataHeaders=["From", "Subject", "Date"],
    ).execute()
    messages = thread.get("messages", [])

    try:
        term_width = os.get_terminal_size().columns
    except OSError:
        term_width = 80

    print(f"Thread: {len(messages)} message(s)", file=sys.stderr)
    print("-" * min(term_width, 72), file=sys.stderr)

    for i, msg in enumerate(messages, 1):
        headers = msg.get("payload", {}).get("headers", [])
        date_str = parse_date(get_header(headers, "Date"))
        sender = parse_sender(get_header(headers, "From"))
        subject = get_header(headers, "Subject") or "(no subject)"

        # Mark the selected message
        marker = ">>>" if msg["id"] == msg_id else "   "
        print(f"{marker} {i}. {date_str}  {sender}")
        if i == 1 or get_header(headers, "Subject") != get_header(
            messages[i - 2].get("payload", {}).get("headers", []), "Subject"
        ):
            print(f"       {subject}")

        # Show snippet (Gmail provides a text snippet)
        snippet = msg.get("snippet", "")
        if snippet:
            if len(snippet) > term_width - 8:
                snippet = snippet[: term_width - 11] + "..."
            print(f"       {snippet}")
        print()


# ---------------------------------------------------------------------------
# Send mode
# ---------------------------------------------------------------------------

def _attach_files(msg, attachments):
    """Add file attachments to an email message, converting to multipart if needed."""
    if not attachments:
        return msg
    # Wrap in multipart/mixed if not already multipart
    if not msg.is_multipart():
        original = msg
        msg = MIMEMultipart()
        # Preserve headers from the original
        for key in ("To", "From", "Subject", "Cc", "Bcc", "Reply-To",
                     "In-Reply-To", "References", "Date", "Message-ID"):
            val = original.get(key)
            if val:
                msg[key] = val
        # Move body to a text part
        body = original.get_payload(decode=True)
        charset = original.get_content_charset() or "utf-8"
        msg.attach(MIMEText(body.decode(charset), original.get_content_subtype(), charset))
    for att_path in attachments:
        p = Path(att_path)
        ctype, _ = mimetypes.guess_type(str(p))
        if ctype is None:
            ctype = "application/octet-stream"
        maintype, subtype = ctype.split("/", 1)
        with open(p, "rb") as f:
            part = MIMEBase(maintype, subtype)
            part.set_payload(f.read())
        email.encoders.encode_base64(part)
        part.add_header("Content-Disposition", "attachment", filename=p.name)
        msg.attach(part)
    return msg


def _build_raw_bytes(args):
    """Build raw email bytes from send/draft args. Shared by do_send and do_draft."""
    if args.header_file:
        raw_bytes = Path(args.header_file).read_bytes()
        if not sys.stdin.isatty():
            body = sys.stdin.read()
            if body.strip():
                raw_bytes = raw_bytes.rstrip() + b"\n\n" + body.encode()
        if args.attach:
            msg = email.message_from_bytes(raw_bytes, policy=email.policy.compat32)
            msg = _attach_files(msg, args.attach)
            raw_bytes = msg.as_bytes()
    else:
        if not args.recipient:
            print("Recipient required (or use -H with an .eml file).", file=sys.stderr)
            sys.exit(1)
        if sys.stdin.isatty():
            body = get_body_interactive(args.recipient, args.subject)
        else:
            body = sys.stdin.read()
        raw_bytes = build_mime_message(
            args.recipient, args.subject, body,
            cc=args.cc, bcc=args.bcc, attachments=args.attach,
        )
    return raw_bytes


def do_send(service, args):
    """Send a message via Gmail API."""
    raw_bytes = _build_raw_bytes(args)
    encoded = base64.urlsafe_b64encode(raw_bytes).decode()
    result = service.users().messages().send(
        userId="me", body={"raw": encoded}
    ).execute()

    msg = email.message_from_bytes(raw_bytes, policy=email.policy.default)
    to = msg.get("To", "(unknown)")
    subj = msg.get("Subject", "(no subject)")
    print(f"Sent: To={to} Subject={subj} id={result.get('id', '?')}", file=sys.stderr)


# ---------------------------------------------------------------------------
# Draft mode
# ---------------------------------------------------------------------------

def do_draft(service, args):
    """Create a draft via Gmail API."""
    raw_bytes = _build_raw_bytes(args)
    encoded = base64.urlsafe_b64encode(raw_bytes).decode()
    result = service.users().drafts().create(
        userId="me", body={"message": {"raw": encoded}}
    ).execute()

    msg = email.message_from_bytes(raw_bytes, policy=email.policy.default)
    to = msg.get("To", "(unknown)")
    subj = msg.get("Subject", "(no subject)")
    print(f"Draft saved: To={to} Subject={subj} id={result.get('id', '?')}", file=sys.stderr)


# ---------------------------------------------------------------------------
# Argument parsing
# ---------------------------------------------------------------------------

def parse_send_draft_args(argv):
    """Parse arguments for send/draft mode."""
    parser = argparse.ArgumentParser(
        prog=f"gmails {argv[0]}",
        description=f"{'Send' if argv[0] == 'send' else 'Draft'} a Gmail message.",
    )
    parser.add_argument("recipient", nargs="?", default=None, help="Recipient email address")
    parser.add_argument("-s", "--subject", default="", help="Subject line")
    parser.add_argument("-H", "--header-file", default=None, help="Use .eml file as message")
    parser.add_argument("-a", "--attach", action="append", default=None, help="Attach file (repeatable)")
    parser.add_argument("-c", "--cc", default=None, help="Cc recipient")
    parser.add_argument("-b", "--bcc", default=None, help="Bcc recipient")
    parser.add_argument("-F", "--config", default=None, help="Muttrc config for account isolation")
    parser.add_argument("-e", "--email", default=None, help="Account email (alternative to -F)")
    parser.add_argument("-Q", "--show-account", action="store_true", help="Show active account and exit")
    return parser.parse_args(argv[1:])


def parse_list_get_args(argv):
    """Parse arguments for list/get mode (original interface)."""
    parser = argparse.ArgumentParser(
        description="List and download Gmail messages.",
        epilog="Run without INDEX to list. Add INDEX to download. Designed for !! workflow.",
    )
    parser.add_argument("index", nargs="?", type=int, default=None, help="Message number to download")
    parser.add_argument("output", nargs="?", default=None, help="Output filename or directory")
    parser.add_argument("-n", "--count", type=int, default=20, help="Number of messages (default: 20)")
    parser.add_argument("-q", "--query", default=None, help="Gmail search query")
    parser.add_argument("-F", "--config", default=None, help="Muttrc config for account isolation")
    parser.add_argument("-e", "--email", default=None, help="Account email (alternative to -F)")
    parser.add_argument("-S", "--stdout", action="store_true", help="Write raw message to stdout (for piping)")
    parser.add_argument("-t", "--text", action="store_true", help="Print text body to stdout (inline view)")
    parser.add_argument("-c", "--just-count", action="store_true", help="Print message count only (for scripting)")
    parser.add_argument("-Q", "--show-account", action="store_true", help="Show active account and exit")
    parser.add_argument("--draft", action="store_true", help="Save reply/fwd as draft instead of sending")
    parser.add_argument("--all", action="store_true", help="Reply-all: include original To and Cc")
    parser.add_argument("-a", "--attach", action="append", default=None, help="Attach file (repeatable)")
    return parser.parse_args(argv)


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

FULL_HELP = """\
gmails - Gmail CLI: list, read, send, and draft messages via Gmail API.

Commands:
  gmails [options] [INDEX [OUTPUT]]     List or download messages
  gmails send [options] [RECIPIENT]     Send a message
  gmails draft [options] [RECIPIENT]    Save a message to Gmail Drafts
  gmails reply INDEX                    Reply to a message (opens $EDITOR)
  gmails reply INDEX --draft            Save reply as draft instead of sending
  gmails fwd INDEX RECIPIENT            Forward a message (opens $EDITOR)
  gmails fwd INDEX RECIPIENT --draft    Save forward as draft
  gmails trash INDEX [INDEX ...]         Move message(s) to trash
  gmails archive INDEX [INDEX ...]      Archive (remove from inbox)
  gmails read INDEX [INDEX ...]         Mark message(s) as read
  gmails unread INDEX [INDEX ...]       Mark message(s) as unread
  gmails open INDEX                     Open a message in Gmail web UI
  gmails thread INDEX                   Show all messages in a conversation
  gmails -E                             List configured accounts

List messages:
  gmails                                List 20 most recent messages
  gmails -n 5                           List 5 most recent
  gmails -q "from:alice"                Search with Gmail query syntax
  gmails -q "is:unread"                 List unread messages
  gmails -q "has:attachment"            List messages with attachments
  gmails -q "newer_than:7d"             Messages from the last 7 days
  gmails -e lake -q "from:buyrite"      Search another account by email substring

Sent mail and search:
  gmails -q "in:sent"                   List sent messages
  gmails -q "in:sent" -n 10             List 10 most recent sent
  gmails -q "in:sent to:alice"          Sent messages to alice
  gmails -q 'from:alice subject:"the proposal"'  Faceted search with phrase

Download a message:
  gmails 3                              Save #3 to /tmp/spool/ (auto-named)
  gmails 3 message.eml                  Save message #3 to file
  gmails 3 /tmp/                        Save to dir (auto-named from headers)
  gmails 3 -S                           Raw message to stdout (for piping)
  gmails 3 -S | grep Subject            Pipe to other tools
  gmails 3 -t                           Print text body inline (quick read)

Reply to a message:
  gmails reply 3                        Reply to message #3 (opens $EDITOR)
  gmails reply 3 --all                  Reply-all (includes To and Cc recipients)
  gmails reply 3 --draft                Save reply as draft (review before sending)
  gmails reply 3 -a slide.pdf           Reply with attachment
  gmails -e lake reply 3                Reply from another account
  gmails -q "from:alice" reply 1        Reply to first search result

Forward a message:
  gmails fwd 3 user@example.com         Forward message #3 (opens $EDITOR)
  gmails fwd 3 user@example.com --draft Save forward as draft
  gmails -e lake fwd 3 user@ex.com      Forward from another account
  gmails -q "from:alice" fwd 1 user@ex.com  Forward a search result

Manage messages:
  gmails trash 3                        Move message #3 to trash
  gmails trash 1 3 5                    Trash multiple messages at once
  gmails archive 3                      Archive message #3 (remove from inbox)
  gmails archive 1 2 3                  Archive multiple messages
  gmails read 3                         Mark message #3 as read
  gmails unread 3                       Mark message #3 as unread
  gmails -q "from:spam" trash 1         Trash a search result
  gmails open 3                         Open message #3 in Gmail web UI
  gmails -e lake open 3                 Open in correct account's Gmail
  gmails thread 3                       Show all messages in #3's conversation

Reply/fwd with piped body:
  echo "thanks" | gmails reply 3        Reply without opening editor
  echo "FYI" | gmails fwd 3 user@ex.com Forward with note from stdin

List output:
  * marks unread messages; summary shows unread count

Send a message:
  echo "body" | gmails send user@example.com -s "subject"
  gmails send user@example.com -s "hi"                     (opens $EDITOR)
  gmails send user@example.com -s "hi" -a report.pdf       (with attachment)
  gmails send user@example.com -a a.pdf -a b.pdf           (multiple attachments)
  gmails send user@example.com -s "hi" -c boss@example.com (with cc)
  gmails send -H message.eml                               (send a pre-built .eml)
  cat body.txt | gmails send -H headers.eml                (eml headers + stdin body)
  gmails -e lake send user@example.com -s "hi"             (send from another account)

Save to Drafts:
  echo "body" | gmails draft user@example.com -s "subject"
  gmails draft user@example.com                            (opens $EDITOR)
  gmails draft -H message.eml                              (draft from .eml file)
  gmails draft user@example.com -s "hi" -a file.pdf        (draft with attachment)

Scripting:
  gmails -c -q "is:unread"              Print unread count (for shell prompts)
  gmails -c -q "from:alice newer_than:1d"  Count recent messages from alice
  gmails -c -e lake -q "is:unread"      Unread count for another account

The !! workflow (list, then act on a result):
  % gmails -n 5 -q "from:alice"
  % !! 3 reply.eml              # re-runs: gmails -n 5 -q "from:alice" 3 reply.eml

List/download options:
  -n, --count N         Number of messages to list (default: 20)
  -q, --query QUERY     Gmail search query (same syntax as the Gmail search bar)

Send/draft options:
  -s, --subject TEXT    Subject line
  -H, --header-file F   Use .eml file as the message (headers and body)
  -a, --attach FILE     Attach a file (repeatable for multiple attachments)
  -c, --cc ADDR         Cc recipient
  -b, --bcc ADDR        Bcc recipient

Common options:
  -F, --config FILE     Muttrc config file for multi-account token isolation
  -e, --email ADDR      Account email or substring (alternative to -F)
  -E, --list-accounts   List configured accounts and exit
  -Q, --show-account    Show which account would be used, then exit
  -S, --stdout          Write raw message to stdout instead of saving to file
  -t, --text            Print text body inline (headers to stderr, body to stdout)
  -c, --just-count      Print message count only (for scripting)
  --all                 Reply-all: include original To and Cc recipients
  --draft               Save reply/fwd as draft instead of sending
  -a, --attach FILE     Attach file to reply/fwd (repeatable)
  -h, --help            Show this help (or: gmails send -h, gmails draft -h)

Environment:
  GMAILS_ACCOUNT        Default account (same as -e). Overridden by -e or -F.

Body input (send/draft):
  If stdin is piped, it becomes the message body.
  If stdin is a terminal and no -H file, opens $EDITOR for composing.
  If -H is given with piped stdin, the .eml provides headers and stdin is appended.

Authentication:
  Uses OAuth via google_auth.py. Tokens are cached per scope in ~/.config/google-tokens/.
  List/download uses gmail-readonly scope. Send/draft uses gmail-compose scope.
  Reply/fwd uses gmail-send scope (readonly + compose combined).
  First use of send/draft/reply will open a browser for OAuth consent.

Multi-account (-F and -e):
  -F: Pass a neomutt-style config file containing 'set imap_user="user@example.com"'.
  -e: Pass an email address or substring to look up in ~/.config/gmails/accounts.
      The accounts file has lines like: user@example.com /path/to/muttrc
      Partial matching works: -e lake matches chris@lakedutchess.com.
  Each account gets isolated OAuth tokens (e.g., gmail-compose-user-at-example-com).
"""


def main():
    # Top-level help: show comprehensive usage for all modes
    if len(sys.argv) < 2 or (
        sys.argv[1] in ("-h", "--help") and
        not (len(sys.argv) > 2 and sys.argv[2] in ("send", "draft", "reply"))
    ):
        if "-h" in sys.argv or "--help" in sys.argv:
            print(FULL_HELP)
            sys.exit(0)

    # -E: list configured accounts and exit
    if "-E" in sys.argv or "--list-accounts" in sys.argv:
        do_list_accounts()

    # Detect mode: find "send", "draft", or "reply" anywhere in argv (skipping flag values)
    mode = None
    rest = sys.argv[1:]
    mode_index = None
    skip_next = False
    for i, arg in enumerate(rest):
        if skip_next:
            skip_next = False
            continue
        if arg in ("-F", "--config", "-e", "--email"):
            skip_next = True  # next arg is the flag's value
            continue
        if arg in ("send", "draft", "reply", "fwd", "trash", "archive", "open", "thread", "read", "unread"):
            mode = arg
            mode_index = i
            break
        if arg.startswith("-"):
            continue
        break  # hit a positional arg that isn't send/draft/reply

    if mode:
        # Rearrange so parse_send_draft_args sees: [mode, ...flags..., ...args...]
        # Move common flags from before the mode into the post-mode args
        pre = rest[:mode_index]
        post = rest[mode_index:]  # starts with "send"/"draft"
        rest = [post[0]] + pre + post[1:]

    if mode in ("send", "draft"):
        args = parse_send_draft_args(rest)
        token_name, login_hint = resolve_account(args.config, args.email, "gmail-send")
        if args.show_account:
            print(login_hint or "(default account)")
            sys.exit(0)
        creds = get_credentials(service="gmail", scopes="gmail-send",
                                token_name=token_name, login_hint=login_hint)
        service = build("gmail", "v1", credentials=creds)
        if mode == "send":
            do_send(service, args)
        else:
            do_draft(service, args)
    elif mode == "reply":
        # reply needs both readonly (to fetch) and compose (to send)
        reply_rest = [a for a in rest if a != "reply"]
        args = parse_list_get_args(reply_rest)
        if args.index is None:
            print("Usage: gmails reply INDEX (e.g., gmails reply 3)", file=sys.stderr)
            sys.exit(1)
        token_name, login_hint = resolve_account(args.config, args.email, "gmail-send")
        if args.show_account:
            print(login_hint or "(default account)")
            sys.exit(0)
        creds = get_credentials(service="gmail", scopes="gmail-send",
                                token_name=token_name, login_hint=login_hint)
        service = build("gmail", "v1", credentials=creds)
        do_reply(service, args.index, args.count, args.query, args,
                 as_draft=args.draft, account=login_hint)
    elif mode == "fwd":
        fwd_rest = [a for a in rest if a != "fwd"]
        args = parse_list_get_args(fwd_rest)
        if args.index is None or args.output is None:
            print("Usage: gmails fwd INDEX RECIPIENT (e.g., gmails fwd 3 user@example.com)", file=sys.stderr)
            sys.exit(1)
        recipient = args.output  # the "output" positional is the recipient for fwd
        token_name, login_hint = resolve_account(args.config, args.email, "gmail-send")
        if args.show_account:
            print(login_hint or "(default account)")
            sys.exit(0)
        creds = get_credentials(service="gmail", scopes="gmail-send",
                                token_name=token_name, login_hint=login_hint)
        service = build("gmail", "v1", credentials=creds)
        do_forward(service, args.index, args.count, args.query, recipient,
                   as_draft=args.draft, account=login_hint)
    elif mode in ("trash", "archive", "open", "thread", "read", "unread"):
        mode_rest = [a for a in rest if a != mode]
        # For multi-index modes, extract all bare integers as indices
        indices = []
        filtered_rest = []
        skip_next = False
        for arg in mode_rest:
            if skip_next:
                filtered_rest.append(arg)
                skip_next = False
                continue
            if arg in ("-n", "--count", "-q", "--query", "-F", "--config", "-e", "--email"):
                filtered_rest.append(arg)
                skip_next = True
                continue
            if arg.startswith("-"):
                filtered_rest.append(arg)
                continue
            try:
                indices.append(int(arg))
            except ValueError:
                filtered_rest.append(arg)
        args = parse_list_get_args(filtered_rest)
        if not indices:
            print(f"Usage: gmails {mode} INDEX [INDEX ...] (e.g., gmails {mode} 3)", file=sys.stderr)
            sys.exit(1)
        # trash/archive/read/unread need write access; open and thread only need read
        scope = "gmail-send" if mode in ("trash", "archive", "read", "unread") else "gmail-readonly"
        token_name, login_hint = resolve_account(args.config, args.email, scope)
        if args.show_account:
            print(login_hint or "(default account)")
            sys.exit(0)
        creds = get_credentials(service="gmail", scopes=scope,
                                token_name=token_name, login_hint=login_hint)
        service = build("gmail", "v1", credentials=creds)
        if mode == "trash":
            do_trash(service, indices, args.count, args.query, account=login_hint)
        elif mode == "archive":
            do_archive(service, indices, args.count, args.query, account=login_hint)
        elif mode == "read":
            do_mark_read(service, indices, args.count, args.query, account=login_hint)
        elif mode == "unread":
            do_mark_unread(service, indices, args.count, args.query, account=login_hint)
        elif mode == "open":
            do_open(service, args.index, args.count, args.query, account=login_hint)
        else:
            do_thread(service, args.index, args.count, args.query, account=login_hint)
    else:
        args = parse_list_get_args(rest)
        # -t marks as read, which needs modify permission
        scope = "gmail-send" if args.text else "gmail-readonly"
        token_name, login_hint = resolve_account(args.config, args.email, scope)
        if args.show_account:
            print(login_hint or "(default account)")
            sys.exit(0)
        creds = get_credentials(service="gmail", scopes=scope,
                                token_name=token_name, login_hint=login_hint)
        service = build("gmail", "v1", credentials=creds)
        if args.just_count:
            kwargs = {"userId": "me", "maxResults": args.count}
            if args.query:
                kwargs["q"] = args.query
            result = service.users().messages().list(**kwargs).execute()
            print(result.get("resultSizeEstimate", 0))
            sys.exit(0)
        if args.index is None:
            do_list(service, args.count, args.query, account=login_hint)
        else:
            do_get(service, args.index, args.count, args.query, args.output,
                   stdout=args.stdout, text_view=args.text, account=login_hint)


if __name__ == "__main__":
    main()
